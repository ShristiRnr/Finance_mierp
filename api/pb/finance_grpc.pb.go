// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.0
// source: finance.proto

package financepb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	InvoiceService_CreateInvoice_FullMethodName  = "/finance.InvoiceService/CreateInvoice"
	InvoiceService_GetInvoice_FullMethodName     = "/finance.InvoiceService/GetInvoice"
	InvoiceService_ListInvoices_FullMethodName   = "/finance.InvoiceService/ListInvoices"
	InvoiceService_SearchInvoices_FullMethodName = "/finance.InvoiceService/SearchInvoices"
	InvoiceService_UpdateInvoice_FullMethodName  = "/finance.InvoiceService/UpdateInvoice"
	InvoiceService_DeleteInvoice_FullMethodName  = "/finance.InvoiceService/DeleteInvoice"
)

// InvoiceServiceClient is the client API for InvoiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InvoiceServiceClient interface {
	CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	GetInvoice(ctx context.Context, in *GetInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	ListInvoices(ctx context.Context, in *ListInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error)
	SearchInvoices(ctx context.Context, in *SearchInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error)
	UpdateInvoice(ctx context.Context, in *UpdateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	DeleteInvoice(ctx context.Context, in *DeleteInvoiceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type invoiceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInvoiceServiceClient(cc grpc.ClientConnInterface) InvoiceServiceClient {
	return &invoiceServiceClient{cc}
}

func (c *invoiceServiceClient) CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, InvoiceService_CreateInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) GetInvoice(ctx context.Context, in *GetInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, InvoiceService_GetInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) ListInvoices(ctx context.Context, in *ListInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInvoicesResponse)
	err := c.cc.Invoke(ctx, InvoiceService_ListInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) SearchInvoices(ctx context.Context, in *SearchInvoicesRequest, opts ...grpc.CallOption) (*ListInvoicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInvoicesResponse)
	err := c.cc.Invoke(ctx, InvoiceService_SearchInvoices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) UpdateInvoice(ctx context.Context, in *UpdateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, InvoiceService_UpdateInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *invoiceServiceClient) DeleteInvoice(ctx context.Context, in *DeleteInvoiceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, InvoiceService_DeleteInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InvoiceServiceServer is the server API for InvoiceService service.
// All implementations must embed UnimplementedInvoiceServiceServer
// for forward compatibility.
type InvoiceServiceServer interface {
	CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error)
	GetInvoice(context.Context, *GetInvoiceRequest) (*Invoice, error)
	ListInvoices(context.Context, *ListInvoicesRequest) (*ListInvoicesResponse, error)
	SearchInvoices(context.Context, *SearchInvoicesRequest) (*ListInvoicesResponse, error)
	UpdateInvoice(context.Context, *UpdateInvoiceRequest) (*Invoice, error)
	DeleteInvoice(context.Context, *DeleteInvoiceRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInvoiceServiceServer()
}

// UnimplementedInvoiceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInvoiceServiceServer struct{}

func (UnimplementedInvoiceServiceServer) CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) GetInvoice(context.Context, *GetInvoiceRequest) (*Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) ListInvoices(context.Context, *ListInvoicesRequest) (*ListInvoicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInvoices not implemented")
}
func (UnimplementedInvoiceServiceServer) SearchInvoices(context.Context, *SearchInvoicesRequest) (*ListInvoicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchInvoices not implemented")
}
func (UnimplementedInvoiceServiceServer) UpdateInvoice(context.Context, *UpdateInvoiceRequest) (*Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) DeleteInvoice(context.Context, *DeleteInvoiceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInvoice not implemented")
}
func (UnimplementedInvoiceServiceServer) mustEmbedUnimplementedInvoiceServiceServer() {}
func (UnimplementedInvoiceServiceServer) testEmbeddedByValue()                        {}

// UnsafeInvoiceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InvoiceServiceServer will
// result in compilation errors.
type UnsafeInvoiceServiceServer interface {
	mustEmbedUnimplementedInvoiceServiceServer()
}

func RegisterInvoiceServiceServer(s grpc.ServiceRegistrar, srv InvoiceServiceServer) {
	// If the following call pancis, it indicates UnimplementedInvoiceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InvoiceService_ServiceDesc, srv)
}

func _InvoiceService_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_CreateInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).CreateInvoice(ctx, req.(*CreateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_GetInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).GetInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_GetInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).GetInvoice(ctx, req.(*GetInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInvoicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).ListInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_ListInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).ListInvoices(ctx, req.(*ListInvoicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_SearchInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchInvoicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).SearchInvoices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_SearchInvoices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).SearchInvoices(ctx, req.(*SearchInvoicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_UpdateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).UpdateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_UpdateInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).UpdateInvoice(ctx, req.(*UpdateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InvoiceService_DeleteInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InvoiceServiceServer).DeleteInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InvoiceService_DeleteInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InvoiceServiceServer).DeleteInvoice(ctx, req.(*DeleteInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InvoiceService_ServiceDesc is the grpc.ServiceDesc for InvoiceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InvoiceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.InvoiceService",
	HandlerType: (*InvoiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateInvoice",
			Handler:    _InvoiceService_CreateInvoice_Handler,
		},
		{
			MethodName: "GetInvoice",
			Handler:    _InvoiceService_GetInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _InvoiceService_ListInvoices_Handler,
		},
		{
			MethodName: "SearchInvoices",
			Handler:    _InvoiceService_SearchInvoices_Handler,
		},
		{
			MethodName: "UpdateInvoice",
			Handler:    _InvoiceService_UpdateInvoice_Handler,
		},
		{
			MethodName: "DeleteInvoice",
			Handler:    _InvoiceService_DeleteInvoice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	CreditDebitNoteService_CreateCreditDebitNote_FullMethodName = "/finance.CreditDebitNoteService/CreateCreditDebitNote"
	CreditDebitNoteService_GetCreditDebitNote_FullMethodName    = "/finance.CreditDebitNoteService/GetCreditDebitNote"
	CreditDebitNoteService_ListCreditDebitNotes_FullMethodName  = "/finance.CreditDebitNoteService/ListCreditDebitNotes"
	CreditDebitNoteService_UpdateCreditDebitNote_FullMethodName = "/finance.CreditDebitNoteService/UpdateCreditDebitNote"
	CreditDebitNoteService_DeleteCreditDebitNote_FullMethodName = "/finance.CreditDebitNoteService/DeleteCreditDebitNote"
)

// CreditDebitNoteServiceClient is the client API for CreditDebitNoteService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CreditDebitNoteServiceClient interface {
	CreateCreditDebitNote(ctx context.Context, in *CreateCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error)
	GetCreditDebitNote(ctx context.Context, in *GetCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error)
	ListCreditDebitNotes(ctx context.Context, in *ListCreditDebitNotesRequest, opts ...grpc.CallOption) (*ListCreditDebitNotesResponse, error)
	UpdateCreditDebitNote(ctx context.Context, in *UpdateCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error)
	DeleteCreditDebitNote(ctx context.Context, in *DeleteCreditDebitNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type creditDebitNoteServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCreditDebitNoteServiceClient(cc grpc.ClientConnInterface) CreditDebitNoteServiceClient {
	return &creditDebitNoteServiceClient{cc}
}

func (c *creditDebitNoteServiceClient) CreateCreditDebitNote(ctx context.Context, in *CreateCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreditDebitNote)
	err := c.cc.Invoke(ctx, CreditDebitNoteService_CreateCreditDebitNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditDebitNoteServiceClient) GetCreditDebitNote(ctx context.Context, in *GetCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreditDebitNote)
	err := c.cc.Invoke(ctx, CreditDebitNoteService_GetCreditDebitNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditDebitNoteServiceClient) ListCreditDebitNotes(ctx context.Context, in *ListCreditDebitNotesRequest, opts ...grpc.CallOption) (*ListCreditDebitNotesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCreditDebitNotesResponse)
	err := c.cc.Invoke(ctx, CreditDebitNoteService_ListCreditDebitNotes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditDebitNoteServiceClient) UpdateCreditDebitNote(ctx context.Context, in *UpdateCreditDebitNoteRequest, opts ...grpc.CallOption) (*CreditDebitNote, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreditDebitNote)
	err := c.cc.Invoke(ctx, CreditDebitNoteService_UpdateCreditDebitNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *creditDebitNoteServiceClient) DeleteCreditDebitNote(ctx context.Context, in *DeleteCreditDebitNoteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CreditDebitNoteService_DeleteCreditDebitNote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CreditDebitNoteServiceServer is the server API for CreditDebitNoteService service.
// All implementations must embed UnimplementedCreditDebitNoteServiceServer
// for forward compatibility.
type CreditDebitNoteServiceServer interface {
	CreateCreditDebitNote(context.Context, *CreateCreditDebitNoteRequest) (*CreditDebitNote, error)
	GetCreditDebitNote(context.Context, *GetCreditDebitNoteRequest) (*CreditDebitNote, error)
	ListCreditDebitNotes(context.Context, *ListCreditDebitNotesRequest) (*ListCreditDebitNotesResponse, error)
	UpdateCreditDebitNote(context.Context, *UpdateCreditDebitNoteRequest) (*CreditDebitNote, error)
	DeleteCreditDebitNote(context.Context, *DeleteCreditDebitNoteRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedCreditDebitNoteServiceServer()
}

// UnimplementedCreditDebitNoteServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCreditDebitNoteServiceServer struct{}

func (UnimplementedCreditDebitNoteServiceServer) CreateCreditDebitNote(context.Context, *CreateCreditDebitNoteRequest) (*CreditDebitNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCreditDebitNote not implemented")
}
func (UnimplementedCreditDebitNoteServiceServer) GetCreditDebitNote(context.Context, *GetCreditDebitNoteRequest) (*CreditDebitNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCreditDebitNote not implemented")
}
func (UnimplementedCreditDebitNoteServiceServer) ListCreditDebitNotes(context.Context, *ListCreditDebitNotesRequest) (*ListCreditDebitNotesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCreditDebitNotes not implemented")
}
func (UnimplementedCreditDebitNoteServiceServer) UpdateCreditDebitNote(context.Context, *UpdateCreditDebitNoteRequest) (*CreditDebitNote, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCreditDebitNote not implemented")
}
func (UnimplementedCreditDebitNoteServiceServer) DeleteCreditDebitNote(context.Context, *DeleteCreditDebitNoteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCreditDebitNote not implemented")
}
func (UnimplementedCreditDebitNoteServiceServer) mustEmbedUnimplementedCreditDebitNoteServiceServer() {
}
func (UnimplementedCreditDebitNoteServiceServer) testEmbeddedByValue() {}

// UnsafeCreditDebitNoteServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CreditDebitNoteServiceServer will
// result in compilation errors.
type UnsafeCreditDebitNoteServiceServer interface {
	mustEmbedUnimplementedCreditDebitNoteServiceServer()
}

func RegisterCreditDebitNoteServiceServer(s grpc.ServiceRegistrar, srv CreditDebitNoteServiceServer) {
	// If the following call pancis, it indicates UnimplementedCreditDebitNoteServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CreditDebitNoteService_ServiceDesc, srv)
}

func _CreditDebitNoteService_CreateCreditDebitNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCreditDebitNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditDebitNoteServiceServer).CreateCreditDebitNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditDebitNoteService_CreateCreditDebitNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditDebitNoteServiceServer).CreateCreditDebitNote(ctx, req.(*CreateCreditDebitNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditDebitNoteService_GetCreditDebitNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreditDebitNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditDebitNoteServiceServer).GetCreditDebitNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditDebitNoteService_GetCreditDebitNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditDebitNoteServiceServer).GetCreditDebitNote(ctx, req.(*GetCreditDebitNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditDebitNoteService_ListCreditDebitNotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCreditDebitNotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditDebitNoteServiceServer).ListCreditDebitNotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditDebitNoteService_ListCreditDebitNotes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditDebitNoteServiceServer).ListCreditDebitNotes(ctx, req.(*ListCreditDebitNotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditDebitNoteService_UpdateCreditDebitNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCreditDebitNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditDebitNoteServiceServer).UpdateCreditDebitNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditDebitNoteService_UpdateCreditDebitNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditDebitNoteServiceServer).UpdateCreditDebitNote(ctx, req.(*UpdateCreditDebitNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CreditDebitNoteService_DeleteCreditDebitNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCreditDebitNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CreditDebitNoteServiceServer).DeleteCreditDebitNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CreditDebitNoteService_DeleteCreditDebitNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CreditDebitNoteServiceServer).DeleteCreditDebitNote(ctx, req.(*DeleteCreditDebitNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CreditDebitNoteService_ServiceDesc is the grpc.ServiceDesc for CreditDebitNoteService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CreditDebitNoteService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.CreditDebitNoteService",
	HandlerType: (*CreditDebitNoteServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCreditDebitNote",
			Handler:    _CreditDebitNoteService_CreateCreditDebitNote_Handler,
		},
		{
			MethodName: "GetCreditDebitNote",
			Handler:    _CreditDebitNoteService_GetCreditDebitNote_Handler,
		},
		{
			MethodName: "ListCreditDebitNotes",
			Handler:    _CreditDebitNoteService_ListCreditDebitNotes_Handler,
		},
		{
			MethodName: "UpdateCreditDebitNote",
			Handler:    _CreditDebitNoteService_UpdateCreditDebitNote_Handler,
		},
		{
			MethodName: "DeleteCreditDebitNote",
			Handler:    _CreditDebitNoteService_DeleteCreditDebitNote_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	PaymentService_CreatePaymentDue_FullMethodName       = "/finance.PaymentService/CreatePaymentDue"
	PaymentService_GetPaymentDue_FullMethodName          = "/finance.PaymentService/GetPaymentDue"
	PaymentService_UpdatePaymentDue_FullMethodName       = "/finance.PaymentService/UpdatePaymentDue"
	PaymentService_DeletePaymentDue_FullMethodName       = "/finance.PaymentService/DeletePaymentDue"
	PaymentService_MarkPaymentAsPaid_FullMethodName      = "/finance.PaymentService/MarkPaymentAsPaid"
	PaymentService_ListPaymentDues_FullMethodName        = "/finance.PaymentService/ListPaymentDues"
	PaymentService_CreateBankAccount_FullMethodName      = "/finance.PaymentService/CreateBankAccount"
	PaymentService_GetBankAccount_FullMethodName         = "/finance.PaymentService/GetBankAccount"
	PaymentService_UpdateBankAccount_FullMethodName      = "/finance.PaymentService/UpdateBankAccount"
	PaymentService_DeleteBankAccount_FullMethodName      = "/finance.PaymentService/DeleteBankAccount"
	PaymentService_ListBankAccounts_FullMethodName       = "/finance.PaymentService/ListBankAccounts"
	PaymentService_ImportBankTransactions_FullMethodName = "/finance.PaymentService/ImportBankTransactions"
	PaymentService_ListBankTransactions_FullMethodName   = "/finance.PaymentService/ListBankTransactions"
)

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentServiceClient interface {
	CreatePaymentDue(ctx context.Context, in *CreatePaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error)
	GetPaymentDue(ctx context.Context, in *GetPaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error)
	UpdatePaymentDue(ctx context.Context, in *UpdatePaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error)
	DeletePaymentDue(ctx context.Context, in *DeletePaymentDueRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	MarkPaymentAsPaid(ctx context.Context, in *MarkPaymentAsPaidRequest, opts ...grpc.CallOption) (*PaymentDue, error)
	ListPaymentDues(ctx context.Context, in *ListPaymentDuesRequest, opts ...grpc.CallOption) (*ListPaymentDuesResponse, error)
	// Bank accounts & statements
	CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error)
	GetBankAccount(ctx context.Context, in *GetBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error)
	UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error)
	DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListBankAccounts(ctx context.Context, in *ListBankAccountsRequest, opts ...grpc.CallOption) (*ListBankAccountsResponse, error)
	ImportBankTransactions(ctx context.Context, in *ImportBankTransactionsRequest, opts ...grpc.CallOption) (*ImportBankTransactionsResponse, error)
	ListBankTransactions(ctx context.Context, in *ListBankTransactionsRequest, opts ...grpc.CallOption) (*ListBankTransactionsResponse, error)
}

type paymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient {
	return &paymentServiceClient{cc}
}

func (c *paymentServiceClient) CreatePaymentDue(ctx context.Context, in *CreatePaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDue)
	err := c.cc.Invoke(ctx, PaymentService_CreatePaymentDue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) GetPaymentDue(ctx context.Context, in *GetPaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDue)
	err := c.cc.Invoke(ctx, PaymentService_GetPaymentDue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) UpdatePaymentDue(ctx context.Context, in *UpdatePaymentDueRequest, opts ...grpc.CallOption) (*PaymentDue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDue)
	err := c.cc.Invoke(ctx, PaymentService_UpdatePaymentDue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) DeletePaymentDue(ctx context.Context, in *DeletePaymentDueRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PaymentService_DeletePaymentDue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) MarkPaymentAsPaid(ctx context.Context, in *MarkPaymentAsPaidRequest, opts ...grpc.CallOption) (*PaymentDue, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDue)
	err := c.cc.Invoke(ctx, PaymentService_MarkPaymentAsPaid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ListPaymentDues(ctx context.Context, in *ListPaymentDuesRequest, opts ...grpc.CallOption) (*ListPaymentDuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPaymentDuesResponse)
	err := c.cc.Invoke(ctx, PaymentService_ListPaymentDues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccount)
	err := c.cc.Invoke(ctx, PaymentService_CreateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) GetBankAccount(ctx context.Context, in *GetBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccount)
	err := c.cc.Invoke(ctx, PaymentService_GetBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*BankAccount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccount)
	err := c.cc.Invoke(ctx, PaymentService_UpdateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PaymentService_DeleteBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ListBankAccounts(ctx context.Context, in *ListBankAccountsRequest, opts ...grpc.CallOption) (*ListBankAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBankAccountsResponse)
	err := c.cc.Invoke(ctx, PaymentService_ListBankAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ImportBankTransactions(ctx context.Context, in *ImportBankTransactionsRequest, opts ...grpc.CallOption) (*ImportBankTransactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportBankTransactionsResponse)
	err := c.cc.Invoke(ctx, PaymentService_ImportBankTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ListBankTransactions(ctx context.Context, in *ListBankTransactionsRequest, opts ...grpc.CallOption) (*ListBankTransactionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBankTransactionsResponse)
	err := c.cc.Invoke(ctx, PaymentService_ListBankTransactions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility.
type PaymentServiceServer interface {
	CreatePaymentDue(context.Context, *CreatePaymentDueRequest) (*PaymentDue, error)
	GetPaymentDue(context.Context, *GetPaymentDueRequest) (*PaymentDue, error)
	UpdatePaymentDue(context.Context, *UpdatePaymentDueRequest) (*PaymentDue, error)
	DeletePaymentDue(context.Context, *DeletePaymentDueRequest) (*emptypb.Empty, error)
	MarkPaymentAsPaid(context.Context, *MarkPaymentAsPaidRequest) (*PaymentDue, error)
	ListPaymentDues(context.Context, *ListPaymentDuesRequest) (*ListPaymentDuesResponse, error)
	// Bank accounts & statements
	CreateBankAccount(context.Context, *CreateBankAccountRequest) (*BankAccount, error)
	GetBankAccount(context.Context, *GetBankAccountRequest) (*BankAccount, error)
	UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*BankAccount, error)
	DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*emptypb.Empty, error)
	ListBankAccounts(context.Context, *ListBankAccountsRequest) (*ListBankAccountsResponse, error)
	ImportBankTransactions(context.Context, *ImportBankTransactionsRequest) (*ImportBankTransactionsResponse, error)
	ListBankTransactions(context.Context, *ListBankTransactionsRequest) (*ListBankTransactionsResponse, error)
	mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentServiceServer struct{}

func (UnimplementedPaymentServiceServer) CreatePaymentDue(context.Context, *CreatePaymentDueRequest) (*PaymentDue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePaymentDue not implemented")
}
func (UnimplementedPaymentServiceServer) GetPaymentDue(context.Context, *GetPaymentDueRequest) (*PaymentDue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentDue not implemented")
}
func (UnimplementedPaymentServiceServer) UpdatePaymentDue(context.Context, *UpdatePaymentDueRequest) (*PaymentDue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePaymentDue not implemented")
}
func (UnimplementedPaymentServiceServer) DeletePaymentDue(context.Context, *DeletePaymentDueRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePaymentDue not implemented")
}
func (UnimplementedPaymentServiceServer) MarkPaymentAsPaid(context.Context, *MarkPaymentAsPaidRequest) (*PaymentDue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkPaymentAsPaid not implemented")
}
func (UnimplementedPaymentServiceServer) ListPaymentDues(context.Context, *ListPaymentDuesRequest) (*ListPaymentDuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPaymentDues not implemented")
}
func (UnimplementedPaymentServiceServer) CreateBankAccount(context.Context, *CreateBankAccountRequest) (*BankAccount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBankAccount not implemented")
}
func (UnimplementedPaymentServiceServer) GetBankAccount(context.Context, *GetBankAccountRequest) (*BankAccount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBankAccount not implemented")
}
func (UnimplementedPaymentServiceServer) UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*BankAccount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBankAccount not implemented")
}
func (UnimplementedPaymentServiceServer) DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBankAccount not implemented")
}
func (UnimplementedPaymentServiceServer) ListBankAccounts(context.Context, *ListBankAccountsRequest) (*ListBankAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBankAccounts not implemented")
}
func (UnimplementedPaymentServiceServer) ImportBankTransactions(context.Context, *ImportBankTransactionsRequest) (*ImportBankTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportBankTransactions not implemented")
}
func (UnimplementedPaymentServiceServer) ListBankTransactions(context.Context, *ListBankTransactionsRequest) (*ListBankTransactionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBankTransactions not implemented")
}
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {}
func (UnimplementedPaymentServiceServer) testEmbeddedByValue()                        {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) {
	// If the following call pancis, it indicates UnimplementedPaymentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PaymentService_ServiceDesc, srv)
}

func _PaymentService_CreatePaymentDue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentDueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).CreatePaymentDue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_CreatePaymentDue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).CreatePaymentDue(ctx, req.(*CreatePaymentDueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_GetPaymentDue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentDueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).GetPaymentDue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_GetPaymentDue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).GetPaymentDue(ctx, req.(*GetPaymentDueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_UpdatePaymentDue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePaymentDueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).UpdatePaymentDue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_UpdatePaymentDue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).UpdatePaymentDue(ctx, req.(*UpdatePaymentDueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_DeletePaymentDue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePaymentDueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).DeletePaymentDue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_DeletePaymentDue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).DeletePaymentDue(ctx, req.(*DeletePaymentDueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_MarkPaymentAsPaid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkPaymentAsPaidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).MarkPaymentAsPaid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_MarkPaymentAsPaid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).MarkPaymentAsPaid(ctx, req.(*MarkPaymentAsPaidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ListPaymentDues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentDuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ListPaymentDues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ListPaymentDues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ListPaymentDues(ctx, req.(*ListPaymentDuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_CreateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).CreateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_CreateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).CreateBankAccount(ctx, req.(*CreateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_GetBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).GetBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_GetBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).GetBankAccount(ctx, req.(*GetBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_UpdateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).UpdateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_UpdateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).UpdateBankAccount(ctx, req.(*UpdateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_DeleteBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).DeleteBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_DeleteBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).DeleteBankAccount(ctx, req.(*DeleteBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ListBankAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBankAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ListBankAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ListBankAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ListBankAccounts(ctx, req.(*ListBankAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ImportBankTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportBankTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ImportBankTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ImportBankTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ImportBankTransactions(ctx, req.(*ImportBankTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ListBankTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBankTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ListBankTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ListBankTransactions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ListBankTransactions(ctx, req.(*ListBankTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.PaymentService",
	HandlerType: (*PaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePaymentDue",
			Handler:    _PaymentService_CreatePaymentDue_Handler,
		},
		{
			MethodName: "GetPaymentDue",
			Handler:    _PaymentService_GetPaymentDue_Handler,
		},
		{
			MethodName: "UpdatePaymentDue",
			Handler:    _PaymentService_UpdatePaymentDue_Handler,
		},
		{
			MethodName: "DeletePaymentDue",
			Handler:    _PaymentService_DeletePaymentDue_Handler,
		},
		{
			MethodName: "MarkPaymentAsPaid",
			Handler:    _PaymentService_MarkPaymentAsPaid_Handler,
		},
		{
			MethodName: "ListPaymentDues",
			Handler:    _PaymentService_ListPaymentDues_Handler,
		},
		{
			MethodName: "CreateBankAccount",
			Handler:    _PaymentService_CreateBankAccount_Handler,
		},
		{
			MethodName: "GetBankAccount",
			Handler:    _PaymentService_GetBankAccount_Handler,
		},
		{
			MethodName: "UpdateBankAccount",
			Handler:    _PaymentService_UpdateBankAccount_Handler,
		},
		{
			MethodName: "DeleteBankAccount",
			Handler:    _PaymentService_DeleteBankAccount_Handler,
		},
		{
			MethodName: "ListBankAccounts",
			Handler:    _PaymentService_ListBankAccounts_Handler,
		},
		{
			MethodName: "ImportBankTransactions",
			Handler:    _PaymentService_ImportBankTransactions_Handler,
		},
		{
			MethodName: "ListBankTransactions",
			Handler:    _PaymentService_ListBankTransactions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	BankReconciliationService_ReconcileTransaction_FullMethodName = "/finance.BankReconciliationService/ReconcileTransaction"
)

// BankReconciliationServiceClient is the client API for BankReconciliationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BankReconciliationServiceClient interface {
	ReconcileTransaction(ctx context.Context, in *ReconcileTransactionRequest, opts ...grpc.CallOption) (*Reconciliation, error)
}

type bankReconciliationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBankReconciliationServiceClient(cc grpc.ClientConnInterface) BankReconciliationServiceClient {
	return &bankReconciliationServiceClient{cc}
}

func (c *bankReconciliationServiceClient) ReconcileTransaction(ctx context.Context, in *ReconcileTransactionRequest, opts ...grpc.CallOption) (*Reconciliation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Reconciliation)
	err := c.cc.Invoke(ctx, BankReconciliationService_ReconcileTransaction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BankReconciliationServiceServer is the server API for BankReconciliationService service.
// All implementations must embed UnimplementedBankReconciliationServiceServer
// for forward compatibility.
type BankReconciliationServiceServer interface {
	ReconcileTransaction(context.Context, *ReconcileTransactionRequest) (*Reconciliation, error)
	mustEmbedUnimplementedBankReconciliationServiceServer()
}

// UnimplementedBankReconciliationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBankReconciliationServiceServer struct{}

func (UnimplementedBankReconciliationServiceServer) ReconcileTransaction(context.Context, *ReconcileTransactionRequest) (*Reconciliation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReconcileTransaction not implemented")
}
func (UnimplementedBankReconciliationServiceServer) mustEmbedUnimplementedBankReconciliationServiceServer() {
}
func (UnimplementedBankReconciliationServiceServer) testEmbeddedByValue() {}

// UnsafeBankReconciliationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BankReconciliationServiceServer will
// result in compilation errors.
type UnsafeBankReconciliationServiceServer interface {
	mustEmbedUnimplementedBankReconciliationServiceServer()
}

func RegisterBankReconciliationServiceServer(s grpc.ServiceRegistrar, srv BankReconciliationServiceServer) {
	// If the following call pancis, it indicates UnimplementedBankReconciliationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BankReconciliationService_ServiceDesc, srv)
}

func _BankReconciliationService_ReconcileTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconcileTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BankReconciliationServiceServer).ReconcileTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BankReconciliationService_ReconcileTransaction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BankReconciliationServiceServer).ReconcileTransaction(ctx, req.(*ReconcileTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BankReconciliationService_ServiceDesc is the grpc.ServiceDesc for BankReconciliationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BankReconciliationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.BankReconciliationService",
	HandlerType: (*BankReconciliationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReconcileTransaction",
			Handler:    _BankReconciliationService_ReconcileTransaction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	LedgerService_CreateAccount_FullMethodName      = "/finance.LedgerService/CreateAccount"
	LedgerService_GetAccount_FullMethodName         = "/finance.LedgerService/GetAccount"
	LedgerService_UpdateAccount_FullMethodName      = "/finance.LedgerService/UpdateAccount"
	LedgerService_DeleteAccount_FullMethodName      = "/finance.LedgerService/DeleteAccount"
	LedgerService_ListAccounts_FullMethodName       = "/finance.LedgerService/ListAccounts"
	LedgerService_CreateJournalEntry_FullMethodName = "/finance.LedgerService/CreateJournalEntry"
	LedgerService_GetJournalEntry_FullMethodName    = "/finance.LedgerService/GetJournalEntry"
	LedgerService_UpdateJournalEntry_FullMethodName = "/finance.LedgerService/UpdateJournalEntry"
	LedgerService_DeleteJournalEntry_FullMethodName = "/finance.LedgerService/DeleteJournalEntry"
	LedgerService_ListJournalEntries_FullMethodName = "/finance.LedgerService/ListJournalEntries"
	LedgerService_ListLedgerEntries_FullMethodName  = "/finance.LedgerService/ListLedgerEntries"
)

// LedgerServiceClient is the client API for LedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LedgerServiceClient interface {
	// COA
	CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*Account, error)
	GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error)
	UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*Account, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error)
	// Journal (double-entry)
	CreateJournalEntry(ctx context.Context, in *CreateJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error)
	GetJournalEntry(ctx context.Context, in *GetJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error)
	UpdateJournalEntry(ctx context.Context, in *UpdateJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error)
	DeleteJournalEntry(ctx context.Context, in *DeleteJournalEntryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListJournalEntries(ctx context.Context, in *ListJournalEntriesRequest, opts ...grpc.CallOption) (*ListJournalEntriesResponse, error)
	// Ledger (read-only)
	ListLedgerEntries(ctx context.Context, in *ListLedgerEntriesRequest, opts ...grpc.CallOption) (*ListLedgerEntriesResponse, error)
}

type ledgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLedgerServiceClient(cc grpc.ClientConnInterface) LedgerServiceClient {
	return &ledgerServiceClient{cc}
}

func (c *ledgerServiceClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Account)
	err := c.cc.Invoke(ctx, LedgerService_CreateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) GetAccount(ctx context.Context, in *GetAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Account)
	err := c.cc.Invoke(ctx, LedgerService_GetAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) UpdateAccount(ctx context.Context, in *UpdateAccountRequest, opts ...grpc.CallOption) (*Account, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Account)
	err := c.cc.Invoke(ctx, LedgerService_UpdateAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LedgerService_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) ListAccounts(ctx context.Context, in *ListAccountsRequest, opts ...grpc.CallOption) (*ListAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAccountsResponse)
	err := c.cc.Invoke(ctx, LedgerService_ListAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) CreateJournalEntry(ctx context.Context, in *CreateJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalEntry)
	err := c.cc.Invoke(ctx, LedgerService_CreateJournalEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) GetJournalEntry(ctx context.Context, in *GetJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalEntry)
	err := c.cc.Invoke(ctx, LedgerService_GetJournalEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) UpdateJournalEntry(ctx context.Context, in *UpdateJournalEntryRequest, opts ...grpc.CallOption) (*JournalEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JournalEntry)
	err := c.cc.Invoke(ctx, LedgerService_UpdateJournalEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) DeleteJournalEntry(ctx context.Context, in *DeleteJournalEntryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LedgerService_DeleteJournalEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) ListJournalEntries(ctx context.Context, in *ListJournalEntriesRequest, opts ...grpc.CallOption) (*ListJournalEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListJournalEntriesResponse)
	err := c.cc.Invoke(ctx, LedgerService_ListJournalEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) ListLedgerEntries(ctx context.Context, in *ListLedgerEntriesRequest, opts ...grpc.CallOption) (*ListLedgerEntriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLedgerEntriesResponse)
	err := c.cc.Invoke(ctx, LedgerService_ListLedgerEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LedgerServiceServer is the server API for LedgerService service.
// All implementations must embed UnimplementedLedgerServiceServer
// for forward compatibility.
type LedgerServiceServer interface {
	// COA
	CreateAccount(context.Context, *CreateAccountRequest) (*Account, error)
	GetAccount(context.Context, *GetAccountRequest) (*Account, error)
	UpdateAccount(context.Context, *UpdateAccountRequest) (*Account, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error)
	ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error)
	// Journal (double-entry)
	CreateJournalEntry(context.Context, *CreateJournalEntryRequest) (*JournalEntry, error)
	GetJournalEntry(context.Context, *GetJournalEntryRequest) (*JournalEntry, error)
	UpdateJournalEntry(context.Context, *UpdateJournalEntryRequest) (*JournalEntry, error)
	DeleteJournalEntry(context.Context, *DeleteJournalEntryRequest) (*emptypb.Empty, error)
	ListJournalEntries(context.Context, *ListJournalEntriesRequest) (*ListJournalEntriesResponse, error)
	// Ledger (read-only)
	ListLedgerEntries(context.Context, *ListLedgerEntriesRequest) (*ListLedgerEntriesResponse, error)
	mustEmbedUnimplementedLedgerServiceServer()
}

// UnimplementedLedgerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLedgerServiceServer struct{}

func (UnimplementedLedgerServiceServer) CreateAccount(context.Context, *CreateAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccount not implemented")
}
func (UnimplementedLedgerServiceServer) GetAccount(context.Context, *GetAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}
func (UnimplementedLedgerServiceServer) UpdateAccount(context.Context, *UpdateAccountRequest) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccount not implemented")
}
func (UnimplementedLedgerServiceServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedLedgerServiceServer) ListAccounts(context.Context, *ListAccountsRequest) (*ListAccountsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccounts not implemented")
}
func (UnimplementedLedgerServiceServer) CreateJournalEntry(context.Context, *CreateJournalEntryRequest) (*JournalEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJournalEntry not implemented")
}
func (UnimplementedLedgerServiceServer) GetJournalEntry(context.Context, *GetJournalEntryRequest) (*JournalEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJournalEntry not implemented")
}
func (UnimplementedLedgerServiceServer) UpdateJournalEntry(context.Context, *UpdateJournalEntryRequest) (*JournalEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJournalEntry not implemented")
}
func (UnimplementedLedgerServiceServer) DeleteJournalEntry(context.Context, *DeleteJournalEntryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJournalEntry not implemented")
}
func (UnimplementedLedgerServiceServer) ListJournalEntries(context.Context, *ListJournalEntriesRequest) (*ListJournalEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJournalEntries not implemented")
}
func (UnimplementedLedgerServiceServer) ListLedgerEntries(context.Context, *ListLedgerEntriesRequest) (*ListLedgerEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLedgerEntries not implemented")
}
func (UnimplementedLedgerServiceServer) mustEmbedUnimplementedLedgerServiceServer() {}
func (UnimplementedLedgerServiceServer) testEmbeddedByValue()                       {}

// UnsafeLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerServiceServer will
// result in compilation errors.
type UnsafeLedgerServiceServer interface {
	mustEmbedUnimplementedLedgerServiceServer()
}

func RegisterLedgerServiceServer(s grpc.ServiceRegistrar, srv LedgerServiceServer) {
	// If the following call pancis, it indicates UnimplementedLedgerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LedgerService_ServiceDesc, srv)
}

func _LedgerService_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_CreateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).CreateAccount(ctx, req.(*CreateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_GetAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).GetAccount(ctx, req.(*GetAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_UpdateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).UpdateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_UpdateAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).UpdateAccount(ctx, req.(*UpdateAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).ListAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_ListAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).ListAccounts(ctx, req.(*ListAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_CreateJournalEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJournalEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).CreateJournalEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_CreateJournalEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).CreateJournalEntry(ctx, req.(*CreateJournalEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_GetJournalEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJournalEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).GetJournalEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_GetJournalEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).GetJournalEntry(ctx, req.(*GetJournalEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_UpdateJournalEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJournalEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).UpdateJournalEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_UpdateJournalEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).UpdateJournalEntry(ctx, req.(*UpdateJournalEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_DeleteJournalEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJournalEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).DeleteJournalEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_DeleteJournalEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).DeleteJournalEntry(ctx, req.(*DeleteJournalEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_ListJournalEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJournalEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).ListJournalEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_ListJournalEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).ListJournalEntries(ctx, req.(*ListJournalEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_ListLedgerEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLedgerEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).ListLedgerEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_ListLedgerEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).ListLedgerEntries(ctx, req.(*ListLedgerEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LedgerService_ServiceDesc is the grpc.ServiceDesc for LedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.LedgerService",
	HandlerType: (*LedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccount",
			Handler:    _LedgerService_CreateAccount_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _LedgerService_GetAccount_Handler,
		},
		{
			MethodName: "UpdateAccount",
			Handler:    _LedgerService_UpdateAccount_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _LedgerService_DeleteAccount_Handler,
		},
		{
			MethodName: "ListAccounts",
			Handler:    _LedgerService_ListAccounts_Handler,
		},
		{
			MethodName: "CreateJournalEntry",
			Handler:    _LedgerService_CreateJournalEntry_Handler,
		},
		{
			MethodName: "GetJournalEntry",
			Handler:    _LedgerService_GetJournalEntry_Handler,
		},
		{
			MethodName: "UpdateJournalEntry",
			Handler:    _LedgerService_UpdateJournalEntry_Handler,
		},
		{
			MethodName: "DeleteJournalEntry",
			Handler:    _LedgerService_DeleteJournalEntry_Handler,
		},
		{
			MethodName: "ListJournalEntries",
			Handler:    _LedgerService_ListJournalEntries_Handler,
		},
		{
			MethodName: "ListLedgerEntries",
			Handler:    _LedgerService_ListLedgerEntries_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	BudgetService_CreateBudget_FullMethodName = "/finance.BudgetService/CreateBudget"
	BudgetService_GetBudget_FullMethodName    = "/finance.BudgetService/GetBudget"
	BudgetService_UpdateBudget_FullMethodName = "/finance.BudgetService/UpdateBudget"
	BudgetService_DeleteBudget_FullMethodName = "/finance.BudgetService/DeleteBudget"
	BudgetService_ListBudgets_FullMethodName  = "/finance.BudgetService/ListBudgets"
)

// BudgetServiceClient is the client API for BudgetService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BudgetServiceClient interface {
	CreateBudget(ctx context.Context, in *CreateBudgetRequest, opts ...grpc.CallOption) (*Budget, error)
	GetBudget(ctx context.Context, in *GetBudgetRequest, opts ...grpc.CallOption) (*Budget, error)
	UpdateBudget(ctx context.Context, in *UpdateBudgetRequest, opts ...grpc.CallOption) (*Budget, error)
	DeleteBudget(ctx context.Context, in *DeleteBudgetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListBudgets(ctx context.Context, in *ListBudgetsRequest, opts ...grpc.CallOption) (*ListBudgetsResponse, error)
}

type budgetServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBudgetServiceClient(cc grpc.ClientConnInterface) BudgetServiceClient {
	return &budgetServiceClient{cc}
}

func (c *budgetServiceClient) CreateBudget(ctx context.Context, in *CreateBudgetRequest, opts ...grpc.CallOption) (*Budget, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Budget)
	err := c.cc.Invoke(ctx, BudgetService_CreateBudget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetServiceClient) GetBudget(ctx context.Context, in *GetBudgetRequest, opts ...grpc.CallOption) (*Budget, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Budget)
	err := c.cc.Invoke(ctx, BudgetService_GetBudget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetServiceClient) UpdateBudget(ctx context.Context, in *UpdateBudgetRequest, opts ...grpc.CallOption) (*Budget, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Budget)
	err := c.cc.Invoke(ctx, BudgetService_UpdateBudget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetServiceClient) DeleteBudget(ctx context.Context, in *DeleteBudgetRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BudgetService_DeleteBudget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetServiceClient) ListBudgets(ctx context.Context, in *ListBudgetsRequest, opts ...grpc.CallOption) (*ListBudgetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBudgetsResponse)
	err := c.cc.Invoke(ctx, BudgetService_ListBudgets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BudgetServiceServer is the server API for BudgetService service.
// All implementations must embed UnimplementedBudgetServiceServer
// for forward compatibility.
type BudgetServiceServer interface {
	CreateBudget(context.Context, *CreateBudgetRequest) (*Budget, error)
	GetBudget(context.Context, *GetBudgetRequest) (*Budget, error)
	UpdateBudget(context.Context, *UpdateBudgetRequest) (*Budget, error)
	DeleteBudget(context.Context, *DeleteBudgetRequest) (*emptypb.Empty, error)
	ListBudgets(context.Context, *ListBudgetsRequest) (*ListBudgetsResponse, error)
	mustEmbedUnimplementedBudgetServiceServer()
}

// UnimplementedBudgetServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBudgetServiceServer struct{}

func (UnimplementedBudgetServiceServer) CreateBudget(context.Context, *CreateBudgetRequest) (*Budget, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBudget not implemented")
}
func (UnimplementedBudgetServiceServer) GetBudget(context.Context, *GetBudgetRequest) (*Budget, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBudget not implemented")
}
func (UnimplementedBudgetServiceServer) UpdateBudget(context.Context, *UpdateBudgetRequest) (*Budget, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBudget not implemented")
}
func (UnimplementedBudgetServiceServer) DeleteBudget(context.Context, *DeleteBudgetRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBudget not implemented")
}
func (UnimplementedBudgetServiceServer) ListBudgets(context.Context, *ListBudgetsRequest) (*ListBudgetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBudgets not implemented")
}
func (UnimplementedBudgetServiceServer) mustEmbedUnimplementedBudgetServiceServer() {}
func (UnimplementedBudgetServiceServer) testEmbeddedByValue()                       {}

// UnsafeBudgetServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BudgetServiceServer will
// result in compilation errors.
type UnsafeBudgetServiceServer interface {
	mustEmbedUnimplementedBudgetServiceServer()
}

func RegisterBudgetServiceServer(s grpc.ServiceRegistrar, srv BudgetServiceServer) {
	// If the following call pancis, it indicates UnimplementedBudgetServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BudgetService_ServiceDesc, srv)
}

func _BudgetService_CreateBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBudgetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetServiceServer).CreateBudget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetService_CreateBudget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetServiceServer).CreateBudget(ctx, req.(*CreateBudgetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetService_GetBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBudgetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetServiceServer).GetBudget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetService_GetBudget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetServiceServer).GetBudget(ctx, req.(*GetBudgetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetService_UpdateBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBudgetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetServiceServer).UpdateBudget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetService_UpdateBudget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetServiceServer).UpdateBudget(ctx, req.(*UpdateBudgetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetService_DeleteBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBudgetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetServiceServer).DeleteBudget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetService_DeleteBudget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetServiceServer).DeleteBudget(ctx, req.(*DeleteBudgetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetService_ListBudgets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBudgetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetServiceServer).ListBudgets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetService_ListBudgets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetServiceServer).ListBudgets(ctx, req.(*ListBudgetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BudgetService_ServiceDesc is the grpc.ServiceDesc for BudgetService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BudgetService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.BudgetService",
	HandlerType: (*BudgetServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBudget",
			Handler:    _BudgetService_CreateBudget_Handler,
		},
		{
			MethodName: "GetBudget",
			Handler:    _BudgetService_GetBudget_Handler,
		},
		{
			MethodName: "UpdateBudget",
			Handler:    _BudgetService_UpdateBudget_Handler,
		},
		{
			MethodName: "DeleteBudget",
			Handler:    _BudgetService_DeleteBudget_Handler,
		},
		{
			MethodName: "ListBudgets",
			Handler:    _BudgetService_ListBudgets_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	BudgetAllocationService_AllocateBudget_FullMethodName         = "/finance.BudgetAllocationService/AllocateBudget"
	BudgetAllocationService_GetBudgetAllocation_FullMethodName    = "/finance.BudgetAllocationService/GetBudgetAllocation"
	BudgetAllocationService_UpdateBudgetAllocation_FullMethodName = "/finance.BudgetAllocationService/UpdateBudgetAllocation"
	BudgetAllocationService_DeleteBudgetAllocation_FullMethodName = "/finance.BudgetAllocationService/DeleteBudgetAllocation"
	BudgetAllocationService_ListBudgetAllocations_FullMethodName  = "/finance.BudgetAllocationService/ListBudgetAllocations"
)

// BudgetAllocationServiceClient is the client API for BudgetAllocationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BudgetAllocationServiceClient interface {
	AllocateBudget(ctx context.Context, in *AllocateBudgetRequest, opts ...grpc.CallOption) (*BudgetAllocation, error)
	GetBudgetAllocation(ctx context.Context, in *GetBudgetAllocationRequest, opts ...grpc.CallOption) (*BudgetAllocation, error)
	UpdateBudgetAllocation(ctx context.Context, in *UpdateBudgetAllocationRequest, opts ...grpc.CallOption) (*BudgetAllocation, error)
	DeleteBudgetAllocation(ctx context.Context, in *DeleteBudgetAllocationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListBudgetAllocations(ctx context.Context, in *ListBudgetAllocationsRequest, opts ...grpc.CallOption) (*ListBudgetAllocationsResponse, error)
}

type budgetAllocationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBudgetAllocationServiceClient(cc grpc.ClientConnInterface) BudgetAllocationServiceClient {
	return &budgetAllocationServiceClient{cc}
}

func (c *budgetAllocationServiceClient) AllocateBudget(ctx context.Context, in *AllocateBudgetRequest, opts ...grpc.CallOption) (*BudgetAllocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BudgetAllocation)
	err := c.cc.Invoke(ctx, BudgetAllocationService_AllocateBudget_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetAllocationServiceClient) GetBudgetAllocation(ctx context.Context, in *GetBudgetAllocationRequest, opts ...grpc.CallOption) (*BudgetAllocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BudgetAllocation)
	err := c.cc.Invoke(ctx, BudgetAllocationService_GetBudgetAllocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetAllocationServiceClient) UpdateBudgetAllocation(ctx context.Context, in *UpdateBudgetAllocationRequest, opts ...grpc.CallOption) (*BudgetAllocation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BudgetAllocation)
	err := c.cc.Invoke(ctx, BudgetAllocationService_UpdateBudgetAllocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetAllocationServiceClient) DeleteBudgetAllocation(ctx context.Context, in *DeleteBudgetAllocationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, BudgetAllocationService_DeleteBudgetAllocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *budgetAllocationServiceClient) ListBudgetAllocations(ctx context.Context, in *ListBudgetAllocationsRequest, opts ...grpc.CallOption) (*ListBudgetAllocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBudgetAllocationsResponse)
	err := c.cc.Invoke(ctx, BudgetAllocationService_ListBudgetAllocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BudgetAllocationServiceServer is the server API for BudgetAllocationService service.
// All implementations must embed UnimplementedBudgetAllocationServiceServer
// for forward compatibility.
type BudgetAllocationServiceServer interface {
	AllocateBudget(context.Context, *AllocateBudgetRequest) (*BudgetAllocation, error)
	GetBudgetAllocation(context.Context, *GetBudgetAllocationRequest) (*BudgetAllocation, error)
	UpdateBudgetAllocation(context.Context, *UpdateBudgetAllocationRequest) (*BudgetAllocation, error)
	DeleteBudgetAllocation(context.Context, *DeleteBudgetAllocationRequest) (*emptypb.Empty, error)
	ListBudgetAllocations(context.Context, *ListBudgetAllocationsRequest) (*ListBudgetAllocationsResponse, error)
	mustEmbedUnimplementedBudgetAllocationServiceServer()
}

// UnimplementedBudgetAllocationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBudgetAllocationServiceServer struct{}

func (UnimplementedBudgetAllocationServiceServer) AllocateBudget(context.Context, *AllocateBudgetRequest) (*BudgetAllocation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocateBudget not implemented")
}
func (UnimplementedBudgetAllocationServiceServer) GetBudgetAllocation(context.Context, *GetBudgetAllocationRequest) (*BudgetAllocation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBudgetAllocation not implemented")
}
func (UnimplementedBudgetAllocationServiceServer) UpdateBudgetAllocation(context.Context, *UpdateBudgetAllocationRequest) (*BudgetAllocation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBudgetAllocation not implemented")
}
func (UnimplementedBudgetAllocationServiceServer) DeleteBudgetAllocation(context.Context, *DeleteBudgetAllocationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBudgetAllocation not implemented")
}
func (UnimplementedBudgetAllocationServiceServer) ListBudgetAllocations(context.Context, *ListBudgetAllocationsRequest) (*ListBudgetAllocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBudgetAllocations not implemented")
}
func (UnimplementedBudgetAllocationServiceServer) mustEmbedUnimplementedBudgetAllocationServiceServer() {
}
func (UnimplementedBudgetAllocationServiceServer) testEmbeddedByValue() {}

// UnsafeBudgetAllocationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BudgetAllocationServiceServer will
// result in compilation errors.
type UnsafeBudgetAllocationServiceServer interface {
	mustEmbedUnimplementedBudgetAllocationServiceServer()
}

func RegisterBudgetAllocationServiceServer(s grpc.ServiceRegistrar, srv BudgetAllocationServiceServer) {
	// If the following call pancis, it indicates UnimplementedBudgetAllocationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BudgetAllocationService_ServiceDesc, srv)
}

func _BudgetAllocationService_AllocateBudget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateBudgetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetAllocationServiceServer).AllocateBudget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetAllocationService_AllocateBudget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetAllocationServiceServer).AllocateBudget(ctx, req.(*AllocateBudgetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetAllocationService_GetBudgetAllocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBudgetAllocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetAllocationServiceServer).GetBudgetAllocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetAllocationService_GetBudgetAllocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetAllocationServiceServer).GetBudgetAllocation(ctx, req.(*GetBudgetAllocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetAllocationService_UpdateBudgetAllocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBudgetAllocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetAllocationServiceServer).UpdateBudgetAllocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetAllocationService_UpdateBudgetAllocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetAllocationServiceServer).UpdateBudgetAllocation(ctx, req.(*UpdateBudgetAllocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetAllocationService_DeleteBudgetAllocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBudgetAllocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetAllocationServiceServer).DeleteBudgetAllocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetAllocationService_DeleteBudgetAllocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetAllocationServiceServer).DeleteBudgetAllocation(ctx, req.(*DeleteBudgetAllocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BudgetAllocationService_ListBudgetAllocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBudgetAllocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetAllocationServiceServer).ListBudgetAllocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetAllocationService_ListBudgetAllocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetAllocationServiceServer).ListBudgetAllocations(ctx, req.(*ListBudgetAllocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BudgetAllocationService_ServiceDesc is the grpc.ServiceDesc for BudgetAllocationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BudgetAllocationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.BudgetAllocationService",
	HandlerType: (*BudgetAllocationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllocateBudget",
			Handler:    _BudgetAllocationService_AllocateBudget_Handler,
		},
		{
			MethodName: "GetBudgetAllocation",
			Handler:    _BudgetAllocationService_GetBudgetAllocation_Handler,
		},
		{
			MethodName: "UpdateBudgetAllocation",
			Handler:    _BudgetAllocationService_UpdateBudgetAllocation_Handler,
		},
		{
			MethodName: "DeleteBudgetAllocation",
			Handler:    _BudgetAllocationService_DeleteBudgetAllocation_Handler,
		},
		{
			MethodName: "ListBudgetAllocations",
			Handler:    _BudgetAllocationService_ListBudgetAllocations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	BudgetComparisonService_GetBudgetComparisonReport_FullMethodName = "/finance.BudgetComparisonService/GetBudgetComparisonReport"
)

// BudgetComparisonServiceClient is the client API for BudgetComparisonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BudgetComparisonServiceClient interface {
	GetBudgetComparisonReport(ctx context.Context, in *BudgetComparisonRequest, opts ...grpc.CallOption) (*BudgetComparisonResponse, error)
}

type budgetComparisonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBudgetComparisonServiceClient(cc grpc.ClientConnInterface) BudgetComparisonServiceClient {
	return &budgetComparisonServiceClient{cc}
}

func (c *budgetComparisonServiceClient) GetBudgetComparisonReport(ctx context.Context, in *BudgetComparisonRequest, opts ...grpc.CallOption) (*BudgetComparisonResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BudgetComparisonResponse)
	err := c.cc.Invoke(ctx, BudgetComparisonService_GetBudgetComparisonReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BudgetComparisonServiceServer is the server API for BudgetComparisonService service.
// All implementations must embed UnimplementedBudgetComparisonServiceServer
// for forward compatibility.
type BudgetComparisonServiceServer interface {
	GetBudgetComparisonReport(context.Context, *BudgetComparisonRequest) (*BudgetComparisonResponse, error)
	mustEmbedUnimplementedBudgetComparisonServiceServer()
}

// UnimplementedBudgetComparisonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBudgetComparisonServiceServer struct{}

func (UnimplementedBudgetComparisonServiceServer) GetBudgetComparisonReport(context.Context, *BudgetComparisonRequest) (*BudgetComparisonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBudgetComparisonReport not implemented")
}
func (UnimplementedBudgetComparisonServiceServer) mustEmbedUnimplementedBudgetComparisonServiceServer() {
}
func (UnimplementedBudgetComparisonServiceServer) testEmbeddedByValue() {}

// UnsafeBudgetComparisonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BudgetComparisonServiceServer will
// result in compilation errors.
type UnsafeBudgetComparisonServiceServer interface {
	mustEmbedUnimplementedBudgetComparisonServiceServer()
}

func RegisterBudgetComparisonServiceServer(s grpc.ServiceRegistrar, srv BudgetComparisonServiceServer) {
	// If the following call pancis, it indicates UnimplementedBudgetComparisonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BudgetComparisonService_ServiceDesc, srv)
}

func _BudgetComparisonService_GetBudgetComparisonReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BudgetComparisonRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BudgetComparisonServiceServer).GetBudgetComparisonReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BudgetComparisonService_GetBudgetComparisonReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BudgetComparisonServiceServer).GetBudgetComparisonReport(ctx, req.(*BudgetComparisonRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BudgetComparisonService_ServiceDesc is the grpc.ServiceDesc for BudgetComparisonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BudgetComparisonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.BudgetComparisonService",
	HandlerType: (*BudgetComparisonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBudgetComparisonReport",
			Handler:    _BudgetComparisonService_GetBudgetComparisonReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	ExpenseRateService_CreateExpenseRate_FullMethodName = "/finance.ExpenseRateService/CreateExpenseRate"
	ExpenseRateService_GetExpenseRate_FullMethodName    = "/finance.ExpenseRateService/GetExpenseRate"
	ExpenseRateService_UpdateExpenseRate_FullMethodName = "/finance.ExpenseRateService/UpdateExpenseRate"
	ExpenseRateService_DeleteExpenseRate_FullMethodName = "/finance.ExpenseRateService/DeleteExpenseRate"
	ExpenseRateService_ListExpensesRate_FullMethodName  = "/finance.ExpenseRateService/ListExpensesRate"
)

// ExpenseRateServiceClient is the client API for ExpenseRateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExpenseRateServiceClient interface {
	CreateExpenseRate(ctx context.Context, in *CreateExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error)
	GetExpenseRate(ctx context.Context, in *GetExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error)
	UpdateExpenseRate(ctx context.Context, in *UpdateExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error)
	DeleteExpenseRate(ctx context.Context, in *DeleteExpenseRateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListExpensesRate(ctx context.Context, in *ListExpensesRateRequest, opts ...grpc.CallOption) (*ListExpensesRateResponse, error)
}

type expenseRateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExpenseRateServiceClient(cc grpc.ClientConnInterface) ExpenseRateServiceClient {
	return &expenseRateServiceClient{cc}
}

func (c *expenseRateServiceClient) CreateExpenseRate(ctx context.Context, in *CreateExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExpenseRate)
	err := c.cc.Invoke(ctx, ExpenseRateService_CreateExpenseRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseRateServiceClient) GetExpenseRate(ctx context.Context, in *GetExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExpenseRate)
	err := c.cc.Invoke(ctx, ExpenseRateService_GetExpenseRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseRateServiceClient) UpdateExpenseRate(ctx context.Context, in *UpdateExpenseRateRequest, opts ...grpc.CallOption) (*ExpenseRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExpenseRate)
	err := c.cc.Invoke(ctx, ExpenseRateService_UpdateExpenseRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseRateServiceClient) DeleteExpenseRate(ctx context.Context, in *DeleteExpenseRateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ExpenseRateService_DeleteExpenseRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseRateServiceClient) ListExpensesRate(ctx context.Context, in *ListExpensesRateRequest, opts ...grpc.CallOption) (*ListExpensesRateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExpensesRateResponse)
	err := c.cc.Invoke(ctx, ExpenseRateService_ListExpensesRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExpenseRateServiceServer is the server API for ExpenseRateService service.
// All implementations must embed UnimplementedExpenseRateServiceServer
// for forward compatibility.
type ExpenseRateServiceServer interface {
	CreateExpenseRate(context.Context, *CreateExpenseRateRequest) (*ExpenseRate, error)
	GetExpenseRate(context.Context, *GetExpenseRateRequest) (*ExpenseRate, error)
	UpdateExpenseRate(context.Context, *UpdateExpenseRateRequest) (*ExpenseRate, error)
	DeleteExpenseRate(context.Context, *DeleteExpenseRateRequest) (*emptypb.Empty, error)
	ListExpensesRate(context.Context, *ListExpensesRateRequest) (*ListExpensesRateResponse, error)
	mustEmbedUnimplementedExpenseRateServiceServer()
}

// UnimplementedExpenseRateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedExpenseRateServiceServer struct{}

func (UnimplementedExpenseRateServiceServer) CreateExpenseRate(context.Context, *CreateExpenseRateRequest) (*ExpenseRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExpenseRate not implemented")
}
func (UnimplementedExpenseRateServiceServer) GetExpenseRate(context.Context, *GetExpenseRateRequest) (*ExpenseRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExpenseRate not implemented")
}
func (UnimplementedExpenseRateServiceServer) UpdateExpenseRate(context.Context, *UpdateExpenseRateRequest) (*ExpenseRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExpenseRate not implemented")
}
func (UnimplementedExpenseRateServiceServer) DeleteExpenseRate(context.Context, *DeleteExpenseRateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExpenseRate not implemented")
}
func (UnimplementedExpenseRateServiceServer) ListExpensesRate(context.Context, *ListExpensesRateRequest) (*ListExpensesRateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExpensesRate not implemented")
}
func (UnimplementedExpenseRateServiceServer) mustEmbedUnimplementedExpenseRateServiceServer() {}
func (UnimplementedExpenseRateServiceServer) testEmbeddedByValue()                            {}

// UnsafeExpenseRateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExpenseRateServiceServer will
// result in compilation errors.
type UnsafeExpenseRateServiceServer interface {
	mustEmbedUnimplementedExpenseRateServiceServer()
}

func RegisterExpenseRateServiceServer(s grpc.ServiceRegistrar, srv ExpenseRateServiceServer) {
	// If the following call pancis, it indicates UnimplementedExpenseRateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ExpenseRateService_ServiceDesc, srv)
}

func _ExpenseRateService_CreateExpenseRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExpenseRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseRateServiceServer).CreateExpenseRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpenseRateService_CreateExpenseRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseRateServiceServer).CreateExpenseRate(ctx, req.(*CreateExpenseRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseRateService_GetExpenseRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExpenseRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseRateServiceServer).GetExpenseRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpenseRateService_GetExpenseRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseRateServiceServer).GetExpenseRate(ctx, req.(*GetExpenseRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseRateService_UpdateExpenseRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExpenseRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseRateServiceServer).UpdateExpenseRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpenseRateService_UpdateExpenseRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseRateServiceServer).UpdateExpenseRate(ctx, req.(*UpdateExpenseRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseRateService_DeleteExpenseRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExpenseRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseRateServiceServer).DeleteExpenseRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpenseRateService_DeleteExpenseRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseRateServiceServer).DeleteExpenseRate(ctx, req.(*DeleteExpenseRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseRateService_ListExpensesRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExpensesRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseRateServiceServer).ListExpensesRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExpenseRateService_ListExpensesRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseRateServiceServer).ListExpensesRate(ctx, req.(*ListExpensesRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExpenseRateService_ServiceDesc is the grpc.ServiceDesc for ExpenseRateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExpenseRateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.ExpenseRateService",
	HandlerType: (*ExpenseRateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateExpenseRate",
			Handler:    _ExpenseRateService_CreateExpenseRate_Handler,
		},
		{
			MethodName: "GetExpenseRate",
			Handler:    _ExpenseRateService_GetExpenseRate_Handler,
		},
		{
			MethodName: "UpdateExpenseRate",
			Handler:    _ExpenseRateService_UpdateExpenseRate_Handler,
		},
		{
			MethodName: "DeleteExpenseRate",
			Handler:    _ExpenseRateService_DeleteExpenseRate_Handler,
		},
		{
			MethodName: "ListExpensesRate",
			Handler:    _ExpenseRateService_ListExpensesRate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	CostAccountingService_CreateCostCenter_FullMethodName    = "/finance.CostAccountingService/CreateCostCenter"
	CostAccountingService_GetCostCenter_FullMethodName       = "/finance.CostAccountingService/GetCostCenter"
	CostAccountingService_UpdateCostCenter_FullMethodName    = "/finance.CostAccountingService/UpdateCostCenter"
	CostAccountingService_DeleteCostCenter_FullMethodName    = "/finance.CostAccountingService/DeleteCostCenter"
	CostAccountingService_ListCostCenters_FullMethodName     = "/finance.CostAccountingService/ListCostCenters"
	CostAccountingService_AllocateCost_FullMethodName        = "/finance.CostAccountingService/AllocateCost"
	CostAccountingService_ListCostAllocations_FullMethodName = "/finance.CostAccountingService/ListCostAllocations"
)

// CostAccountingServiceClient is the client API for CostAccountingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CostAccountingServiceClient interface {
	CreateCostCenter(ctx context.Context, in *CreateCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error)
	GetCostCenter(ctx context.Context, in *GetCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error)
	UpdateCostCenter(ctx context.Context, in *UpdateCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error)
	DeleteCostCenter(ctx context.Context, in *DeleteCostCenterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListCostCenters(ctx context.Context, in *ListCostCentersRequest, opts ...grpc.CallOption) (*ListCostCentersResponse, error)
	AllocateCost(ctx context.Context, in *AllocateCostRequest, opts ...grpc.CallOption) (*AllocateCostResponse, error)
	ListCostAllocations(ctx context.Context, in *ListCostAllocationsRequest, opts ...grpc.CallOption) (*ListCostAllocationsResponse, error)
}

type costAccountingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCostAccountingServiceClient(cc grpc.ClientConnInterface) CostAccountingServiceClient {
	return &costAccountingServiceClient{cc}
}

func (c *costAccountingServiceClient) CreateCostCenter(ctx context.Context, in *CreateCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CostCenter)
	err := c.cc.Invoke(ctx, CostAccountingService_CreateCostCenter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) GetCostCenter(ctx context.Context, in *GetCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CostCenter)
	err := c.cc.Invoke(ctx, CostAccountingService_GetCostCenter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) UpdateCostCenter(ctx context.Context, in *UpdateCostCenterRequest, opts ...grpc.CallOption) (*CostCenter, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CostCenter)
	err := c.cc.Invoke(ctx, CostAccountingService_UpdateCostCenter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) DeleteCostCenter(ctx context.Context, in *DeleteCostCenterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CostAccountingService_DeleteCostCenter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) ListCostCenters(ctx context.Context, in *ListCostCentersRequest, opts ...grpc.CallOption) (*ListCostCentersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCostCentersResponse)
	err := c.cc.Invoke(ctx, CostAccountingService_ListCostCenters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) AllocateCost(ctx context.Context, in *AllocateCostRequest, opts ...grpc.CallOption) (*AllocateCostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocateCostResponse)
	err := c.cc.Invoke(ctx, CostAccountingService_AllocateCost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *costAccountingServiceClient) ListCostAllocations(ctx context.Context, in *ListCostAllocationsRequest, opts ...grpc.CallOption) (*ListCostAllocationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCostAllocationsResponse)
	err := c.cc.Invoke(ctx, CostAccountingService_ListCostAllocations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CostAccountingServiceServer is the server API for CostAccountingService service.
// All implementations must embed UnimplementedCostAccountingServiceServer
// for forward compatibility.
type CostAccountingServiceServer interface {
	CreateCostCenter(context.Context, *CreateCostCenterRequest) (*CostCenter, error)
	GetCostCenter(context.Context, *GetCostCenterRequest) (*CostCenter, error)
	UpdateCostCenter(context.Context, *UpdateCostCenterRequest) (*CostCenter, error)
	DeleteCostCenter(context.Context, *DeleteCostCenterRequest) (*emptypb.Empty, error)
	ListCostCenters(context.Context, *ListCostCentersRequest) (*ListCostCentersResponse, error)
	AllocateCost(context.Context, *AllocateCostRequest) (*AllocateCostResponse, error)
	ListCostAllocations(context.Context, *ListCostAllocationsRequest) (*ListCostAllocationsResponse, error)
	mustEmbedUnimplementedCostAccountingServiceServer()
}

// UnimplementedCostAccountingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCostAccountingServiceServer struct{}

func (UnimplementedCostAccountingServiceServer) CreateCostCenter(context.Context, *CreateCostCenterRequest) (*CostCenter, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCostCenter not implemented")
}
func (UnimplementedCostAccountingServiceServer) GetCostCenter(context.Context, *GetCostCenterRequest) (*CostCenter, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCostCenter not implemented")
}
func (UnimplementedCostAccountingServiceServer) UpdateCostCenter(context.Context, *UpdateCostCenterRequest) (*CostCenter, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCostCenter not implemented")
}
func (UnimplementedCostAccountingServiceServer) DeleteCostCenter(context.Context, *DeleteCostCenterRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCostCenter not implemented")
}
func (UnimplementedCostAccountingServiceServer) ListCostCenters(context.Context, *ListCostCentersRequest) (*ListCostCentersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCostCenters not implemented")
}
func (UnimplementedCostAccountingServiceServer) AllocateCost(context.Context, *AllocateCostRequest) (*AllocateCostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocateCost not implemented")
}
func (UnimplementedCostAccountingServiceServer) ListCostAllocations(context.Context, *ListCostAllocationsRequest) (*ListCostAllocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCostAllocations not implemented")
}
func (UnimplementedCostAccountingServiceServer) mustEmbedUnimplementedCostAccountingServiceServer() {}
func (UnimplementedCostAccountingServiceServer) testEmbeddedByValue()                               {}

// UnsafeCostAccountingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CostAccountingServiceServer will
// result in compilation errors.
type UnsafeCostAccountingServiceServer interface {
	mustEmbedUnimplementedCostAccountingServiceServer()
}

func RegisterCostAccountingServiceServer(s grpc.ServiceRegistrar, srv CostAccountingServiceServer) {
	// If the following call pancis, it indicates UnimplementedCostAccountingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CostAccountingService_ServiceDesc, srv)
}

func _CostAccountingService_CreateCostCenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCostCenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).CreateCostCenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_CreateCostCenter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).CreateCostCenter(ctx, req.(*CreateCostCenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_GetCostCenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCostCenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).GetCostCenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_GetCostCenter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).GetCostCenter(ctx, req.(*GetCostCenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_UpdateCostCenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCostCenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).UpdateCostCenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_UpdateCostCenter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).UpdateCostCenter(ctx, req.(*UpdateCostCenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_DeleteCostCenter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCostCenterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).DeleteCostCenter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_DeleteCostCenter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).DeleteCostCenter(ctx, req.(*DeleteCostCenterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_ListCostCenters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCostCentersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).ListCostCenters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_ListCostCenters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).ListCostCenters(ctx, req.(*ListCostCentersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_AllocateCost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllocateCostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).AllocateCost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_AllocateCost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).AllocateCost(ctx, req.(*AllocateCostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CostAccountingService_ListCostAllocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCostAllocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CostAccountingServiceServer).ListCostAllocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CostAccountingService_ListCostAllocations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CostAccountingServiceServer).ListCostAllocations(ctx, req.(*ListCostAllocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CostAccountingService_ServiceDesc is the grpc.ServiceDesc for CostAccountingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CostAccountingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.CostAccountingService",
	HandlerType: (*CostAccountingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCostCenter",
			Handler:    _CostAccountingService_CreateCostCenter_Handler,
		},
		{
			MethodName: "GetCostCenter",
			Handler:    _CostAccountingService_GetCostCenter_Handler,
		},
		{
			MethodName: "UpdateCostCenter",
			Handler:    _CostAccountingService_UpdateCostCenter_Handler,
		},
		{
			MethodName: "DeleteCostCenter",
			Handler:    _CostAccountingService_DeleteCostCenter_Handler,
		},
		{
			MethodName: "ListCostCenters",
			Handler:    _CostAccountingService_ListCostCenters_Handler,
		},
		{
			MethodName: "AllocateCost",
			Handler:    _CostAccountingService_AllocateCost_Handler,
		},
		{
			MethodName: "ListCostAllocations",
			Handler:    _CostAccountingService_ListCostAllocations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	AuditTrailService_RecordAuditEvent_FullMethodName  = "/finance.AuditTrailService/RecordAuditEvent"
	AuditTrailService_ListAuditEvents_FullMethodName   = "/finance.AuditTrailService/ListAuditEvents"
	AuditTrailService_GetAuditEventById_FullMethodName = "/finance.AuditTrailService/GetAuditEventById"
	AuditTrailService_FilterAuditEvents_FullMethodName = "/finance.AuditTrailService/FilterAuditEvents"
)

// AuditTrailServiceClient is the client API for AuditTrailService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuditTrailServiceClient interface {
	RecordAuditEvent(ctx context.Context, in *RecordAuditEventRequest, opts ...grpc.CallOption) (*AuditEvent, error)
	ListAuditEvents(ctx context.Context, in *ListAuditEventsRequest, opts ...grpc.CallOption) (*ListAuditEventsResponse, error)
	GetAuditEventById(ctx context.Context, in *GetAuditEventByIdRequest, opts ...grpc.CallOption) (*AuditEvent, error)
	FilterAuditEvents(ctx context.Context, in *FilterAuditEventsRequest, opts ...grpc.CallOption) (*FilterAuditEventsResponse, error)
}

type auditTrailServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuditTrailServiceClient(cc grpc.ClientConnInterface) AuditTrailServiceClient {
	return &auditTrailServiceClient{cc}
}

func (c *auditTrailServiceClient) RecordAuditEvent(ctx context.Context, in *RecordAuditEventRequest, opts ...grpc.CallOption) (*AuditEvent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuditEvent)
	err := c.cc.Invoke(ctx, AuditTrailService_RecordAuditEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditTrailServiceClient) ListAuditEvents(ctx context.Context, in *ListAuditEventsRequest, opts ...grpc.CallOption) (*ListAuditEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAuditEventsResponse)
	err := c.cc.Invoke(ctx, AuditTrailService_ListAuditEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditTrailServiceClient) GetAuditEventById(ctx context.Context, in *GetAuditEventByIdRequest, opts ...grpc.CallOption) (*AuditEvent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuditEvent)
	err := c.cc.Invoke(ctx, AuditTrailService_GetAuditEventById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *auditTrailServiceClient) FilterAuditEvents(ctx context.Context, in *FilterAuditEventsRequest, opts ...grpc.CallOption) (*FilterAuditEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FilterAuditEventsResponse)
	err := c.cc.Invoke(ctx, AuditTrailService_FilterAuditEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuditTrailServiceServer is the server API for AuditTrailService service.
// All implementations must embed UnimplementedAuditTrailServiceServer
// for forward compatibility.
type AuditTrailServiceServer interface {
	RecordAuditEvent(context.Context, *RecordAuditEventRequest) (*AuditEvent, error)
	ListAuditEvents(context.Context, *ListAuditEventsRequest) (*ListAuditEventsResponse, error)
	GetAuditEventById(context.Context, *GetAuditEventByIdRequest) (*AuditEvent, error)
	FilterAuditEvents(context.Context, *FilterAuditEventsRequest) (*FilterAuditEventsResponse, error)
	mustEmbedUnimplementedAuditTrailServiceServer()
}

// UnimplementedAuditTrailServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuditTrailServiceServer struct{}

func (UnimplementedAuditTrailServiceServer) RecordAuditEvent(context.Context, *RecordAuditEventRequest) (*AuditEvent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordAuditEvent not implemented")
}
func (UnimplementedAuditTrailServiceServer) ListAuditEvents(context.Context, *ListAuditEventsRequest) (*ListAuditEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAuditEvents not implemented")
}
func (UnimplementedAuditTrailServiceServer) GetAuditEventById(context.Context, *GetAuditEventByIdRequest) (*AuditEvent, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditEventById not implemented")
}
func (UnimplementedAuditTrailServiceServer) FilterAuditEvents(context.Context, *FilterAuditEventsRequest) (*FilterAuditEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FilterAuditEvents not implemented")
}
func (UnimplementedAuditTrailServiceServer) mustEmbedUnimplementedAuditTrailServiceServer() {}
func (UnimplementedAuditTrailServiceServer) testEmbeddedByValue()                           {}

// UnsafeAuditTrailServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuditTrailServiceServer will
// result in compilation errors.
type UnsafeAuditTrailServiceServer interface {
	mustEmbedUnimplementedAuditTrailServiceServer()
}

func RegisterAuditTrailServiceServer(s grpc.ServiceRegistrar, srv AuditTrailServiceServer) {
	// If the following call pancis, it indicates UnimplementedAuditTrailServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuditTrailService_ServiceDesc, srv)
}

func _AuditTrailService_RecordAuditEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordAuditEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditTrailServiceServer).RecordAuditEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditTrailService_RecordAuditEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditTrailServiceServer).RecordAuditEvent(ctx, req.(*RecordAuditEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditTrailService_ListAuditEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAuditEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditTrailServiceServer).ListAuditEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditTrailService_ListAuditEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditTrailServiceServer).ListAuditEvents(ctx, req.(*ListAuditEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditTrailService_GetAuditEventById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditEventByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditTrailServiceServer).GetAuditEventById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditTrailService_GetAuditEventById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditTrailServiceServer).GetAuditEventById(ctx, req.(*GetAuditEventByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuditTrailService_FilterAuditEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterAuditEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuditTrailServiceServer).FilterAuditEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuditTrailService_FilterAuditEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuditTrailServiceServer).FilterAuditEvents(ctx, req.(*FilterAuditEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuditTrailService_ServiceDesc is the grpc.ServiceDesc for AuditTrailService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuditTrailService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.AuditTrailService",
	HandlerType: (*AuditTrailServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecordAuditEvent",
			Handler:    _AuditTrailService_RecordAuditEvent_Handler,
		},
		{
			MethodName: "ListAuditEvents",
			Handler:    _AuditTrailService_ListAuditEvents_Handler,
		},
		{
			MethodName: "GetAuditEventById",
			Handler:    _AuditTrailService_GetAuditEventById_Handler,
		},
		{
			MethodName: "FilterAuditEvents",
			Handler:    _AuditTrailService_FilterAuditEvents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	AccrualService_CreateAccrual_FullMethodName  = "/finance.AccrualService/CreateAccrual"
	AccrualService_GetAccrualById_FullMethodName = "/finance.AccrualService/GetAccrualById"
	AccrualService_UpdateAccrual_FullMethodName  = "/finance.AccrualService/UpdateAccrual"
	AccrualService_DeleteAccrual_FullMethodName  = "/finance.AccrualService/DeleteAccrual"
	AccrualService_ListAccruals_FullMethodName   = "/finance.AccrualService/ListAccruals"
)

// AccrualServiceClient is the client API for AccrualService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AccrualServiceClient interface {
	CreateAccrual(ctx context.Context, in *CreateAccrualRequest, opts ...grpc.CallOption) (*Accrual, error)
	GetAccrualById(ctx context.Context, in *GetAccrualByIdRequest, opts ...grpc.CallOption) (*Accrual, error)
	UpdateAccrual(ctx context.Context, in *UpdateAccrualRequest, opts ...grpc.CallOption) (*Accrual, error)
	DeleteAccrual(ctx context.Context, in *DeleteAccrualRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListAccruals(ctx context.Context, in *ListAccrualsRequest, opts ...grpc.CallOption) (*ListAccrualsResponse, error)
}

type accrualServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAccrualServiceClient(cc grpc.ClientConnInterface) AccrualServiceClient {
	return &accrualServiceClient{cc}
}

func (c *accrualServiceClient) CreateAccrual(ctx context.Context, in *CreateAccrualRequest, opts ...grpc.CallOption) (*Accrual, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Accrual)
	err := c.cc.Invoke(ctx, AccrualService_CreateAccrual_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accrualServiceClient) GetAccrualById(ctx context.Context, in *GetAccrualByIdRequest, opts ...grpc.CallOption) (*Accrual, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Accrual)
	err := c.cc.Invoke(ctx, AccrualService_GetAccrualById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accrualServiceClient) UpdateAccrual(ctx context.Context, in *UpdateAccrualRequest, opts ...grpc.CallOption) (*Accrual, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Accrual)
	err := c.cc.Invoke(ctx, AccrualService_UpdateAccrual_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accrualServiceClient) DeleteAccrual(ctx context.Context, in *DeleteAccrualRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AccrualService_DeleteAccrual_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accrualServiceClient) ListAccruals(ctx context.Context, in *ListAccrualsRequest, opts ...grpc.CallOption) (*ListAccrualsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAccrualsResponse)
	err := c.cc.Invoke(ctx, AccrualService_ListAccruals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccrualServiceServer is the server API for AccrualService service.
// All implementations must embed UnimplementedAccrualServiceServer
// for forward compatibility.
type AccrualServiceServer interface {
	CreateAccrual(context.Context, *CreateAccrualRequest) (*Accrual, error)
	GetAccrualById(context.Context, *GetAccrualByIdRequest) (*Accrual, error)
	UpdateAccrual(context.Context, *UpdateAccrualRequest) (*Accrual, error)
	DeleteAccrual(context.Context, *DeleteAccrualRequest) (*emptypb.Empty, error)
	ListAccruals(context.Context, *ListAccrualsRequest) (*ListAccrualsResponse, error)
	mustEmbedUnimplementedAccrualServiceServer()
}

// UnimplementedAccrualServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAccrualServiceServer struct{}

func (UnimplementedAccrualServiceServer) CreateAccrual(context.Context, *CreateAccrualRequest) (*Accrual, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAccrual not implemented")
}
func (UnimplementedAccrualServiceServer) GetAccrualById(context.Context, *GetAccrualByIdRequest) (*Accrual, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccrualById not implemented")
}
func (UnimplementedAccrualServiceServer) UpdateAccrual(context.Context, *UpdateAccrualRequest) (*Accrual, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccrual not implemented")
}
func (UnimplementedAccrualServiceServer) DeleteAccrual(context.Context, *DeleteAccrualRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccrual not implemented")
}
func (UnimplementedAccrualServiceServer) ListAccruals(context.Context, *ListAccrualsRequest) (*ListAccrualsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAccruals not implemented")
}
func (UnimplementedAccrualServiceServer) mustEmbedUnimplementedAccrualServiceServer() {}
func (UnimplementedAccrualServiceServer) testEmbeddedByValue()                        {}

// UnsafeAccrualServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AccrualServiceServer will
// result in compilation errors.
type UnsafeAccrualServiceServer interface {
	mustEmbedUnimplementedAccrualServiceServer()
}

func RegisterAccrualServiceServer(s grpc.ServiceRegistrar, srv AccrualServiceServer) {
	// If the following call pancis, it indicates UnimplementedAccrualServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AccrualService_ServiceDesc, srv)
}

func _AccrualService_CreateAccrual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccrualRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccrualServiceServer).CreateAccrual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccrualService_CreateAccrual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccrualServiceServer).CreateAccrual(ctx, req.(*CreateAccrualRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccrualService_GetAccrualById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccrualByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccrualServiceServer).GetAccrualById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccrualService_GetAccrualById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccrualServiceServer).GetAccrualById(ctx, req.(*GetAccrualByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccrualService_UpdateAccrual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccrualRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccrualServiceServer).UpdateAccrual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccrualService_UpdateAccrual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccrualServiceServer).UpdateAccrual(ctx, req.(*UpdateAccrualRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccrualService_DeleteAccrual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccrualRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccrualServiceServer).DeleteAccrual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccrualService_DeleteAccrual_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccrualServiceServer).DeleteAccrual(ctx, req.(*DeleteAccrualRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccrualService_ListAccruals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccrualsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccrualServiceServer).ListAccruals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AccrualService_ListAccruals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccrualServiceServer).ListAccruals(ctx, req.(*ListAccrualsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AccrualService_ServiceDesc is the grpc.ServiceDesc for AccrualService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AccrualService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.AccrualService",
	HandlerType: (*AccrualServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAccrual",
			Handler:    _AccrualService_CreateAccrual_Handler,
		},
		{
			MethodName: "GetAccrualById",
			Handler:    _AccrualService_GetAccrualById_Handler,
		},
		{
			MethodName: "UpdateAccrual",
			Handler:    _AccrualService_UpdateAccrual_Handler,
		},
		{
			MethodName: "DeleteAccrual",
			Handler:    _AccrualService_DeleteAccrual_Handler,
		},
		{
			MethodName: "ListAccruals",
			Handler:    _AccrualService_ListAccruals_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	AllocationAutomationService_CreateAllocationRule_FullMethodName = "/finance.AllocationAutomationService/CreateAllocationRule"
	AllocationAutomationService_GetAllocationRule_FullMethodName    = "/finance.AllocationAutomationService/GetAllocationRule"
	AllocationAutomationService_UpdateAllocationRule_FullMethodName = "/finance.AllocationAutomationService/UpdateAllocationRule"
	AllocationAutomationService_DeleteAllocationRule_FullMethodName = "/finance.AllocationAutomationService/DeleteAllocationRule"
	AllocationAutomationService_ListAllocationRules_FullMethodName  = "/finance.AllocationAutomationService/ListAllocationRules"
)

// AllocationAutomationServiceClient is the client API for AllocationAutomationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AllocationAutomationServiceClient interface {
	CreateAllocationRule(ctx context.Context, in *CreateAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error)
	GetAllocationRule(ctx context.Context, in *GetAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error)
	UpdateAllocationRule(ctx context.Context, in *UpdateAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error)
	DeleteAllocationRule(ctx context.Context, in *DeleteAllocationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListAllocationRules(ctx context.Context, in *ListAllocationRulesRequest, opts ...grpc.CallOption) (*ListAllocationRulesResponse, error)
}

type allocationAutomationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAllocationAutomationServiceClient(cc grpc.ClientConnInterface) AllocationAutomationServiceClient {
	return &allocationAutomationServiceClient{cc}
}

func (c *allocationAutomationServiceClient) CreateAllocationRule(ctx context.Context, in *CreateAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocationRule)
	err := c.cc.Invoke(ctx, AllocationAutomationService_CreateAllocationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *allocationAutomationServiceClient) GetAllocationRule(ctx context.Context, in *GetAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocationRule)
	err := c.cc.Invoke(ctx, AllocationAutomationService_GetAllocationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *allocationAutomationServiceClient) UpdateAllocationRule(ctx context.Context, in *UpdateAllocationRuleRequest, opts ...grpc.CallOption) (*AllocationRule, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AllocationRule)
	err := c.cc.Invoke(ctx, AllocationAutomationService_UpdateAllocationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *allocationAutomationServiceClient) DeleteAllocationRule(ctx context.Context, in *DeleteAllocationRuleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AllocationAutomationService_DeleteAllocationRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *allocationAutomationServiceClient) ListAllocationRules(ctx context.Context, in *ListAllocationRulesRequest, opts ...grpc.CallOption) (*ListAllocationRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAllocationRulesResponse)
	err := c.cc.Invoke(ctx, AllocationAutomationService_ListAllocationRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AllocationAutomationServiceServer is the server API for AllocationAutomationService service.
// All implementations must embed UnimplementedAllocationAutomationServiceServer
// for forward compatibility.
type AllocationAutomationServiceServer interface {
	CreateAllocationRule(context.Context, *CreateAllocationRuleRequest) (*AllocationRule, error)
	GetAllocationRule(context.Context, *GetAllocationRuleRequest) (*AllocationRule, error)
	UpdateAllocationRule(context.Context, *UpdateAllocationRuleRequest) (*AllocationRule, error)
	DeleteAllocationRule(context.Context, *DeleteAllocationRuleRequest) (*emptypb.Empty, error)
	ListAllocationRules(context.Context, *ListAllocationRulesRequest) (*ListAllocationRulesResponse, error)
	mustEmbedUnimplementedAllocationAutomationServiceServer()
}

// UnimplementedAllocationAutomationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAllocationAutomationServiceServer struct{}

func (UnimplementedAllocationAutomationServiceServer) CreateAllocationRule(context.Context, *CreateAllocationRuleRequest) (*AllocationRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAllocationRule not implemented")
}
func (UnimplementedAllocationAutomationServiceServer) GetAllocationRule(context.Context, *GetAllocationRuleRequest) (*AllocationRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllocationRule not implemented")
}
func (UnimplementedAllocationAutomationServiceServer) UpdateAllocationRule(context.Context, *UpdateAllocationRuleRequest) (*AllocationRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAllocationRule not implemented")
}
func (UnimplementedAllocationAutomationServiceServer) DeleteAllocationRule(context.Context, *DeleteAllocationRuleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllocationRule not implemented")
}
func (UnimplementedAllocationAutomationServiceServer) ListAllocationRules(context.Context, *ListAllocationRulesRequest) (*ListAllocationRulesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllocationRules not implemented")
}
func (UnimplementedAllocationAutomationServiceServer) mustEmbedUnimplementedAllocationAutomationServiceServer() {
}
func (UnimplementedAllocationAutomationServiceServer) testEmbeddedByValue() {}

// UnsafeAllocationAutomationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AllocationAutomationServiceServer will
// result in compilation errors.
type UnsafeAllocationAutomationServiceServer interface {
	mustEmbedUnimplementedAllocationAutomationServiceServer()
}

func RegisterAllocationAutomationServiceServer(s grpc.ServiceRegistrar, srv AllocationAutomationServiceServer) {
	// If the following call pancis, it indicates UnimplementedAllocationAutomationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AllocationAutomationService_ServiceDesc, srv)
}

func _AllocationAutomationService_CreateAllocationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAllocationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocationAutomationServiceServer).CreateAllocationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllocationAutomationService_CreateAllocationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocationAutomationServiceServer).CreateAllocationRule(ctx, req.(*CreateAllocationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AllocationAutomationService_GetAllocationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllocationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocationAutomationServiceServer).GetAllocationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllocationAutomationService_GetAllocationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocationAutomationServiceServer).GetAllocationRule(ctx, req.(*GetAllocationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AllocationAutomationService_UpdateAllocationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAllocationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocationAutomationServiceServer).UpdateAllocationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllocationAutomationService_UpdateAllocationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocationAutomationServiceServer).UpdateAllocationRule(ctx, req.(*UpdateAllocationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AllocationAutomationService_DeleteAllocationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllocationRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocationAutomationServiceServer).DeleteAllocationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllocationAutomationService_DeleteAllocationRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocationAutomationServiceServer).DeleteAllocationRule(ctx, req.(*DeleteAllocationRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AllocationAutomationService_ListAllocationRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAllocationRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AllocationAutomationServiceServer).ListAllocationRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AllocationAutomationService_ListAllocationRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AllocationAutomationServiceServer).ListAllocationRules(ctx, req.(*ListAllocationRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AllocationAutomationService_ServiceDesc is the grpc.ServiceDesc for AllocationAutomationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AllocationAutomationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.AllocationAutomationService",
	HandlerType: (*AllocationAutomationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAllocationRule",
			Handler:    _AllocationAutomationService_CreateAllocationRule_Handler,
		},
		{
			MethodName: "GetAllocationRule",
			Handler:    _AllocationAutomationService_GetAllocationRule_Handler,
		},
		{
			MethodName: "UpdateAllocationRule",
			Handler:    _AllocationAutomationService_UpdateAllocationRule_Handler,
		},
		{
			MethodName: "DeleteAllocationRule",
			Handler:    _AllocationAutomationService_DeleteAllocationRule_Handler,
		},
		{
			MethodName: "ListAllocationRules",
			Handler:    _AllocationAutomationService_ListAllocationRules_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	FinancialReportService_GenerateProfitLossReport_FullMethodName   = "/finance.FinancialReportService/GenerateProfitLossReport"
	FinancialReportService_GenerateBalanceSheetReport_FullMethodName = "/finance.FinancialReportService/GenerateBalanceSheetReport"
	FinancialReportService_GenerateTrialBalanceReport_FullMethodName = "/finance.FinancialReportService/GenerateTrialBalanceReport"
	FinancialReportService_GenerateComplianceReport_FullMethodName   = "/finance.FinancialReportService/GenerateComplianceReport"
)

// FinancialReportServiceClient is the client API for FinancialReportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinancialReportServiceClient interface {
	GenerateProfitLossReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ProfitLossReport, error)
	GenerateBalanceSheetReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*BalanceSheetReport, error)
	GenerateTrialBalanceReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*TrialBalanceReport, error)
	GenerateComplianceReport(ctx context.Context, in *ComplianceReportRequest, opts ...grpc.CallOption) (*ComplianceReport, error)
}

type financialReportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFinancialReportServiceClient(cc grpc.ClientConnInterface) FinancialReportServiceClient {
	return &financialReportServiceClient{cc}
}

func (c *financialReportServiceClient) GenerateProfitLossReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*ProfitLossReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfitLossReport)
	err := c.cc.Invoke(ctx, FinancialReportService_GenerateProfitLossReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financialReportServiceClient) GenerateBalanceSheetReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*BalanceSheetReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BalanceSheetReport)
	err := c.cc.Invoke(ctx, FinancialReportService_GenerateBalanceSheetReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financialReportServiceClient) GenerateTrialBalanceReport(ctx context.Context, in *ReportRequest, opts ...grpc.CallOption) (*TrialBalanceReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrialBalanceReport)
	err := c.cc.Invoke(ctx, FinancialReportService_GenerateTrialBalanceReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financialReportServiceClient) GenerateComplianceReport(ctx context.Context, in *ComplianceReportRequest, opts ...grpc.CallOption) (*ComplianceReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComplianceReport)
	err := c.cc.Invoke(ctx, FinancialReportService_GenerateComplianceReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinancialReportServiceServer is the server API for FinancialReportService service.
// All implementations must embed UnimplementedFinancialReportServiceServer
// for forward compatibility.
type FinancialReportServiceServer interface {
	GenerateProfitLossReport(context.Context, *ReportRequest) (*ProfitLossReport, error)
	GenerateBalanceSheetReport(context.Context, *ReportRequest) (*BalanceSheetReport, error)
	GenerateTrialBalanceReport(context.Context, *ReportRequest) (*TrialBalanceReport, error)
	GenerateComplianceReport(context.Context, *ComplianceReportRequest) (*ComplianceReport, error)
	mustEmbedUnimplementedFinancialReportServiceServer()
}

// UnimplementedFinancialReportServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinancialReportServiceServer struct{}

func (UnimplementedFinancialReportServiceServer) GenerateProfitLossReport(context.Context, *ReportRequest) (*ProfitLossReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateProfitLossReport not implemented")
}
func (UnimplementedFinancialReportServiceServer) GenerateBalanceSheetReport(context.Context, *ReportRequest) (*BalanceSheetReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateBalanceSheetReport not implemented")
}
func (UnimplementedFinancialReportServiceServer) GenerateTrialBalanceReport(context.Context, *ReportRequest) (*TrialBalanceReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateTrialBalanceReport not implemented")
}
func (UnimplementedFinancialReportServiceServer) GenerateComplianceReport(context.Context, *ComplianceReportRequest) (*ComplianceReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateComplianceReport not implemented")
}
func (UnimplementedFinancialReportServiceServer) mustEmbedUnimplementedFinancialReportServiceServer() {
}
func (UnimplementedFinancialReportServiceServer) testEmbeddedByValue() {}

// UnsafeFinancialReportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinancialReportServiceServer will
// result in compilation errors.
type UnsafeFinancialReportServiceServer interface {
	mustEmbedUnimplementedFinancialReportServiceServer()
}

func RegisterFinancialReportServiceServer(s grpc.ServiceRegistrar, srv FinancialReportServiceServer) {
	// If the following call pancis, it indicates UnimplementedFinancialReportServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FinancialReportService_ServiceDesc, srv)
}

func _FinancialReportService_GenerateProfitLossReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinancialReportServiceServer).GenerateProfitLossReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinancialReportService_GenerateProfitLossReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinancialReportServiceServer).GenerateProfitLossReport(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinancialReportService_GenerateBalanceSheetReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinancialReportServiceServer).GenerateBalanceSheetReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinancialReportService_GenerateBalanceSheetReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinancialReportServiceServer).GenerateBalanceSheetReport(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinancialReportService_GenerateTrialBalanceReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinancialReportServiceServer).GenerateTrialBalanceReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinancialReportService_GenerateTrialBalanceReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinancialReportServiceServer).GenerateTrialBalanceReport(ctx, req.(*ReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinancialReportService_GenerateComplianceReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinancialReportServiceServer).GenerateComplianceReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinancialReportService_GenerateComplianceReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinancialReportServiceServer).GenerateComplianceReport(ctx, req.(*ComplianceReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FinancialReportService_ServiceDesc is the grpc.ServiceDesc for FinancialReportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FinancialReportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.FinancialReportService",
	HandlerType: (*FinancialReportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateProfitLossReport",
			Handler:    _FinancialReportService_GenerateProfitLossReport_Handler,
		},
		{
			MethodName: "GenerateBalanceSheetReport",
			Handler:    _FinancialReportService_GenerateBalanceSheetReport_Handler,
		},
		{
			MethodName: "GenerateTrialBalanceReport",
			Handler:    _FinancialReportService_GenerateTrialBalanceReport_Handler,
		},
		{
			MethodName: "GenerateComplianceReport",
			Handler:    _FinancialReportService_GenerateComplianceReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	FinancialComplianceService_GenerateComplianceReport_FullMethodName = "/finance.FinancialComplianceService/GenerateComplianceReport"
)

// FinancialComplianceServiceClient is the client API for FinancialComplianceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinancialComplianceServiceClient interface {
	GenerateComplianceReport(ctx context.Context, in *ComplianceReportRequest, opts ...grpc.CallOption) (*ComplianceReport, error)
}

type financialComplianceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFinancialComplianceServiceClient(cc grpc.ClientConnInterface) FinancialComplianceServiceClient {
	return &financialComplianceServiceClient{cc}
}

func (c *financialComplianceServiceClient) GenerateComplianceReport(ctx context.Context, in *ComplianceReportRequest, opts ...grpc.CallOption) (*ComplianceReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComplianceReport)
	err := c.cc.Invoke(ctx, FinancialComplianceService_GenerateComplianceReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinancialComplianceServiceServer is the server API for FinancialComplianceService service.
// All implementations must embed UnimplementedFinancialComplianceServiceServer
// for forward compatibility.
type FinancialComplianceServiceServer interface {
	GenerateComplianceReport(context.Context, *ComplianceReportRequest) (*ComplianceReport, error)
	mustEmbedUnimplementedFinancialComplianceServiceServer()
}

// UnimplementedFinancialComplianceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinancialComplianceServiceServer struct{}

func (UnimplementedFinancialComplianceServiceServer) GenerateComplianceReport(context.Context, *ComplianceReportRequest) (*ComplianceReport, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateComplianceReport not implemented")
}
func (UnimplementedFinancialComplianceServiceServer) mustEmbedUnimplementedFinancialComplianceServiceServer() {
}
func (UnimplementedFinancialComplianceServiceServer) testEmbeddedByValue() {}

// UnsafeFinancialComplianceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinancialComplianceServiceServer will
// result in compilation errors.
type UnsafeFinancialComplianceServiceServer interface {
	mustEmbedUnimplementedFinancialComplianceServiceServer()
}

func RegisterFinancialComplianceServiceServer(s grpc.ServiceRegistrar, srv FinancialComplianceServiceServer) {
	// If the following call pancis, it indicates UnimplementedFinancialComplianceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FinancialComplianceService_ServiceDesc, srv)
}

func _FinancialComplianceService_GenerateComplianceReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComplianceReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinancialComplianceServiceServer).GenerateComplianceReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinancialComplianceService_GenerateComplianceReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinancialComplianceServiceServer).GenerateComplianceReport(ctx, req.(*ComplianceReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FinancialComplianceService_ServiceDesc is the grpc.ServiceDesc for FinancialComplianceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FinancialComplianceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.FinancialComplianceService",
	HandlerType: (*FinancialComplianceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateComplianceReport",
			Handler:    _FinancialComplianceService_GenerateComplianceReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	ConsolidationService_ConsolidateEntities_FullMethodName = "/finance.ConsolidationService/ConsolidateEntities"
	ConsolidationService_CreateConsolidation_FullMethodName = "/finance.ConsolidationService/CreateConsolidation"
	ConsolidationService_GetConsolidation_FullMethodName    = "/finance.ConsolidationService/GetConsolidation"
	ConsolidationService_ListConsolidations_FullMethodName  = "/finance.ConsolidationService/ListConsolidations"
	ConsolidationService_DeleteConsolidation_FullMethodName = "/finance.ConsolidationService/DeleteConsolidation"
)

// ConsolidationServiceClient is the client API for ConsolidationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsolidationServiceClient interface {
	ConsolidateEntities(ctx context.Context, in *ConsolidationRequest, opts ...grpc.CallOption) (*ConsolidationResponse, error)
	CreateConsolidation(ctx context.Context, in *CreateConsolidationRequest, opts ...grpc.CallOption) (*Consolidation, error)
	GetConsolidation(ctx context.Context, in *GetConsolidationRequest, opts ...grpc.CallOption) (*Consolidation, error)
	ListConsolidations(ctx context.Context, in *ListConsolidationsRequest, opts ...grpc.CallOption) (*ListConsolidationsResponse, error)
	DeleteConsolidation(ctx context.Context, in *DeleteConsolidationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type consolidationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConsolidationServiceClient(cc grpc.ClientConnInterface) ConsolidationServiceClient {
	return &consolidationServiceClient{cc}
}

func (c *consolidationServiceClient) ConsolidateEntities(ctx context.Context, in *ConsolidationRequest, opts ...grpc.CallOption) (*ConsolidationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsolidationResponse)
	err := c.cc.Invoke(ctx, ConsolidationService_ConsolidateEntities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consolidationServiceClient) CreateConsolidation(ctx context.Context, in *CreateConsolidationRequest, opts ...grpc.CallOption) (*Consolidation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Consolidation)
	err := c.cc.Invoke(ctx, ConsolidationService_CreateConsolidation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consolidationServiceClient) GetConsolidation(ctx context.Context, in *GetConsolidationRequest, opts ...grpc.CallOption) (*Consolidation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Consolidation)
	err := c.cc.Invoke(ctx, ConsolidationService_GetConsolidation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consolidationServiceClient) ListConsolidations(ctx context.Context, in *ListConsolidationsRequest, opts ...grpc.CallOption) (*ListConsolidationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsolidationsResponse)
	err := c.cc.Invoke(ctx, ConsolidationService_ListConsolidations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consolidationServiceClient) DeleteConsolidation(ctx context.Context, in *DeleteConsolidationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ConsolidationService_DeleteConsolidation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsolidationServiceServer is the server API for ConsolidationService service.
// All implementations must embed UnimplementedConsolidationServiceServer
// for forward compatibility.
type ConsolidationServiceServer interface {
	ConsolidateEntities(context.Context, *ConsolidationRequest) (*ConsolidationResponse, error)
	CreateConsolidation(context.Context, *CreateConsolidationRequest) (*Consolidation, error)
	GetConsolidation(context.Context, *GetConsolidationRequest) (*Consolidation, error)
	ListConsolidations(context.Context, *ListConsolidationsRequest) (*ListConsolidationsResponse, error)
	DeleteConsolidation(context.Context, *DeleteConsolidationRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedConsolidationServiceServer()
}

// UnimplementedConsolidationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsolidationServiceServer struct{}

func (UnimplementedConsolidationServiceServer) ConsolidateEntities(context.Context, *ConsolidationRequest) (*ConsolidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsolidateEntities not implemented")
}
func (UnimplementedConsolidationServiceServer) CreateConsolidation(context.Context, *CreateConsolidationRequest) (*Consolidation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsolidation not implemented")
}
func (UnimplementedConsolidationServiceServer) GetConsolidation(context.Context, *GetConsolidationRequest) (*Consolidation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsolidation not implemented")
}
func (UnimplementedConsolidationServiceServer) ListConsolidations(context.Context, *ListConsolidationsRequest) (*ListConsolidationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConsolidations not implemented")
}
func (UnimplementedConsolidationServiceServer) DeleteConsolidation(context.Context, *DeleteConsolidationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConsolidation not implemented")
}
func (UnimplementedConsolidationServiceServer) mustEmbedUnimplementedConsolidationServiceServer() {}
func (UnimplementedConsolidationServiceServer) testEmbeddedByValue()                              {}

// UnsafeConsolidationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsolidationServiceServer will
// result in compilation errors.
type UnsafeConsolidationServiceServer interface {
	mustEmbedUnimplementedConsolidationServiceServer()
}

func RegisterConsolidationServiceServer(s grpc.ServiceRegistrar, srv ConsolidationServiceServer) {
	// If the following call pancis, it indicates UnimplementedConsolidationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConsolidationService_ServiceDesc, srv)
}

func _ConsolidationService_ConsolidateEntities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsolidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsolidationServiceServer).ConsolidateEntities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsolidationService_ConsolidateEntities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsolidationServiceServer).ConsolidateEntities(ctx, req.(*ConsolidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsolidationService_CreateConsolidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConsolidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsolidationServiceServer).CreateConsolidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsolidationService_CreateConsolidation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsolidationServiceServer).CreateConsolidation(ctx, req.(*CreateConsolidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsolidationService_GetConsolidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsolidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsolidationServiceServer).GetConsolidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsolidationService_GetConsolidation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsolidationServiceServer).GetConsolidation(ctx, req.(*GetConsolidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsolidationService_ListConsolidations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsolidationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsolidationServiceServer).ListConsolidations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsolidationService_ListConsolidations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsolidationServiceServer).ListConsolidations(ctx, req.(*ListConsolidationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsolidationService_DeleteConsolidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConsolidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsolidationServiceServer).DeleteConsolidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsolidationService_DeleteConsolidation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsolidationServiceServer).DeleteConsolidation(ctx, req.(*DeleteConsolidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConsolidationService_ServiceDesc is the grpc.ServiceDesc for ConsolidationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConsolidationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.ConsolidationService",
	HandlerType: (*ConsolidationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ConsolidateEntities",
			Handler:    _ConsolidationService_ConsolidateEntities_Handler,
		},
		{
			MethodName: "CreateConsolidation",
			Handler:    _ConsolidationService_CreateConsolidation_Handler,
		},
		{
			MethodName: "GetConsolidation",
			Handler:    _ConsolidationService_GetConsolidation_Handler,
		},
		{
			MethodName: "ListConsolidations",
			Handler:    _ConsolidationService_ListConsolidations_Handler,
		},
		{
			MethodName: "DeleteConsolidation",
			Handler:    _ConsolidationService_DeleteConsolidation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	FxService_CreateExchangeRate_FullMethodName = "/finance.FxService/CreateExchangeRate"
	FxService_GetExchangeRate_FullMethodName    = "/finance.FxService/GetExchangeRate"
	FxService_UpdateExchangeRate_FullMethodName = "/finance.FxService/UpdateExchangeRate"
	FxService_DeleteExchangeRate_FullMethodName = "/finance.FxService/DeleteExchangeRate"
	FxService_ListExchangeRates_FullMethodName  = "/finance.FxService/ListExchangeRates"
	FxService_ConvertMoney_FullMethodName       = "/finance.FxService/ConvertMoney"
)

// FxServiceClient is the client API for FxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FxServiceClient interface {
	CreateExchangeRate(ctx context.Context, in *CreateExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error)
	GetExchangeRate(ctx context.Context, in *GetExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error)
	UpdateExchangeRate(ctx context.Context, in *UpdateExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error)
	DeleteExchangeRate(ctx context.Context, in *DeleteExchangeRateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListExchangeRates(ctx context.Context, in *ListExchangeRatesRequest, opts ...grpc.CallOption) (*ListExchangeRatesResponse, error)
	ConvertMoney(ctx context.Context, in *ConvertMoneyRequest, opts ...grpc.CallOption) (*ConvertMoneyResponse, error)
}

type fxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFxServiceClient(cc grpc.ClientConnInterface) FxServiceClient {
	return &fxServiceClient{cc}
}

func (c *fxServiceClient) CreateExchangeRate(ctx context.Context, in *CreateExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExchangeRate)
	err := c.cc.Invoke(ctx, FxService_CreateExchangeRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fxServiceClient) GetExchangeRate(ctx context.Context, in *GetExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExchangeRate)
	err := c.cc.Invoke(ctx, FxService_GetExchangeRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fxServiceClient) UpdateExchangeRate(ctx context.Context, in *UpdateExchangeRateRequest, opts ...grpc.CallOption) (*ExchangeRate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExchangeRate)
	err := c.cc.Invoke(ctx, FxService_UpdateExchangeRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fxServiceClient) DeleteExchangeRate(ctx context.Context, in *DeleteExchangeRateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FxService_DeleteExchangeRate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fxServiceClient) ListExchangeRates(ctx context.Context, in *ListExchangeRatesRequest, opts ...grpc.CallOption) (*ListExchangeRatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExchangeRatesResponse)
	err := c.cc.Invoke(ctx, FxService_ListExchangeRates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fxServiceClient) ConvertMoney(ctx context.Context, in *ConvertMoneyRequest, opts ...grpc.CallOption) (*ConvertMoneyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertMoneyResponse)
	err := c.cc.Invoke(ctx, FxService_ConvertMoney_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FxServiceServer is the server API for FxService service.
// All implementations must embed UnimplementedFxServiceServer
// for forward compatibility.
type FxServiceServer interface {
	CreateExchangeRate(context.Context, *CreateExchangeRateRequest) (*ExchangeRate, error)
	GetExchangeRate(context.Context, *GetExchangeRateRequest) (*ExchangeRate, error)
	UpdateExchangeRate(context.Context, *UpdateExchangeRateRequest) (*ExchangeRate, error)
	DeleteExchangeRate(context.Context, *DeleteExchangeRateRequest) (*emptypb.Empty, error)
	ListExchangeRates(context.Context, *ListExchangeRatesRequest) (*ListExchangeRatesResponse, error)
	ConvertMoney(context.Context, *ConvertMoneyRequest) (*ConvertMoneyResponse, error)
	mustEmbedUnimplementedFxServiceServer()
}

// UnimplementedFxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFxServiceServer struct{}

func (UnimplementedFxServiceServer) CreateExchangeRate(context.Context, *CreateExchangeRateRequest) (*ExchangeRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExchangeRate not implemented")
}
func (UnimplementedFxServiceServer) GetExchangeRate(context.Context, *GetExchangeRateRequest) (*ExchangeRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExchangeRate not implemented")
}
func (UnimplementedFxServiceServer) UpdateExchangeRate(context.Context, *UpdateExchangeRateRequest) (*ExchangeRate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExchangeRate not implemented")
}
func (UnimplementedFxServiceServer) DeleteExchangeRate(context.Context, *DeleteExchangeRateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExchangeRate not implemented")
}
func (UnimplementedFxServiceServer) ListExchangeRates(context.Context, *ListExchangeRatesRequest) (*ListExchangeRatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExchangeRates not implemented")
}
func (UnimplementedFxServiceServer) ConvertMoney(context.Context, *ConvertMoneyRequest) (*ConvertMoneyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertMoney not implemented")
}
func (UnimplementedFxServiceServer) mustEmbedUnimplementedFxServiceServer() {}
func (UnimplementedFxServiceServer) testEmbeddedByValue()                   {}

// UnsafeFxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FxServiceServer will
// result in compilation errors.
type UnsafeFxServiceServer interface {
	mustEmbedUnimplementedFxServiceServer()
}

func RegisterFxServiceServer(s grpc.ServiceRegistrar, srv FxServiceServer) {
	// If the following call pancis, it indicates UnimplementedFxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FxService_ServiceDesc, srv)
}

func _FxService_CreateExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).CreateExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_CreateExchangeRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).CreateExchangeRate(ctx, req.(*CreateExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FxService_GetExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).GetExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_GetExchangeRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).GetExchangeRate(ctx, req.(*GetExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FxService_UpdateExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).UpdateExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_UpdateExchangeRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).UpdateExchangeRate(ctx, req.(*UpdateExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FxService_DeleteExchangeRate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExchangeRateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).DeleteExchangeRate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_DeleteExchangeRate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).DeleteExchangeRate(ctx, req.(*DeleteExchangeRateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FxService_ListExchangeRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExchangeRatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).ListExchangeRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_ListExchangeRates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).ListExchangeRates(ctx, req.(*ListExchangeRatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FxService_ConvertMoney_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertMoneyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FxServiceServer).ConvertMoney(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FxService_ConvertMoney_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FxServiceServer).ConvertMoney(ctx, req.(*ConvertMoneyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FxService_ServiceDesc is the grpc.ServiceDesc for FxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.FxService",
	HandlerType: (*FxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateExchangeRate",
			Handler:    _FxService_CreateExchangeRate_Handler,
		},
		{
			MethodName: "GetExchangeRate",
			Handler:    _FxService_GetExchangeRate_Handler,
		},
		{
			MethodName: "UpdateExchangeRate",
			Handler:    _FxService_UpdateExchangeRate_Handler,
		},
		{
			MethodName: "DeleteExchangeRate",
			Handler:    _FxService_DeleteExchangeRate_Handler,
		},
		{
			MethodName: "ListExchangeRates",
			Handler:    _FxService_ListExchangeRates_Handler,
		},
		{
			MethodName: "ConvertMoney",
			Handler:    _FxService_ConvertMoney_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	CashFlowService_GenerateForecast_FullMethodName = "/finance.CashFlowService/GenerateForecast"
	CashFlowService_GetForecast_FullMethodName      = "/finance.CashFlowService/GetForecast"
	CashFlowService_ListForecasts_FullMethodName    = "/finance.CashFlowService/ListForecasts"
)

// CashFlowServiceClient is the client API for CashFlowService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CashFlowServiceClient interface {
	GenerateForecast(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error)
	GetForecast(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error)
	ListForecasts(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error)
}

type cashFlowServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCashFlowServiceClient(cc grpc.ClientConnInterface) CashFlowServiceClient {
	return &cashFlowServiceClient{cc}
}

func (c *cashFlowServiceClient) GenerateForecast(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CashFlowForecastResponse)
	err := c.cc.Invoke(ctx, CashFlowService_GenerateForecast_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cashFlowServiceClient) GetForecast(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CashFlowForecastResponse)
	err := c.cc.Invoke(ctx, CashFlowService_GetForecast_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cashFlowServiceClient) ListForecasts(ctx context.Context, in *CashFlowForecastRequest, opts ...grpc.CallOption) (*CashFlowForecastResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CashFlowForecastResponse)
	err := c.cc.Invoke(ctx, CashFlowService_ListForecasts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CashFlowServiceServer is the server API for CashFlowService service.
// All implementations must embed UnimplementedCashFlowServiceServer
// for forward compatibility.
type CashFlowServiceServer interface {
	GenerateForecast(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error)
	GetForecast(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error)
	ListForecasts(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error)
	mustEmbedUnimplementedCashFlowServiceServer()
}

// UnimplementedCashFlowServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCashFlowServiceServer struct{}

func (UnimplementedCashFlowServiceServer) GenerateForecast(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateForecast not implemented")
}
func (UnimplementedCashFlowServiceServer) GetForecast(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForecast not implemented")
}
func (UnimplementedCashFlowServiceServer) ListForecasts(context.Context, *CashFlowForecastRequest) (*CashFlowForecastResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListForecasts not implemented")
}
func (UnimplementedCashFlowServiceServer) mustEmbedUnimplementedCashFlowServiceServer() {}
func (UnimplementedCashFlowServiceServer) testEmbeddedByValue()                         {}

// UnsafeCashFlowServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CashFlowServiceServer will
// result in compilation errors.
type UnsafeCashFlowServiceServer interface {
	mustEmbedUnimplementedCashFlowServiceServer()
}

func RegisterCashFlowServiceServer(s grpc.ServiceRegistrar, srv CashFlowServiceServer) {
	// If the following call pancis, it indicates UnimplementedCashFlowServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CashFlowService_ServiceDesc, srv)
}

func _CashFlowService_GenerateForecast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CashFlowForecastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CashFlowServiceServer).GenerateForecast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CashFlowService_GenerateForecast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CashFlowServiceServer).GenerateForecast(ctx, req.(*CashFlowForecastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CashFlowService_GetForecast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CashFlowForecastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CashFlowServiceServer).GetForecast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CashFlowService_GetForecast_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CashFlowServiceServer).GetForecast(ctx, req.(*CashFlowForecastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CashFlowService_ListForecasts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CashFlowForecastRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CashFlowServiceServer).ListForecasts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CashFlowService_ListForecasts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CashFlowServiceServer).ListForecasts(ctx, req.(*CashFlowForecastRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CashFlowService_ServiceDesc is the grpc.ServiceDesc for CashFlowService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CashFlowService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.CashFlowService",
	HandlerType: (*CashFlowServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateForecast",
			Handler:    _CashFlowService_GenerateForecast_Handler,
		},
		{
			MethodName: "GetForecast",
			Handler:    _CashFlowService_GetForecast_Handler,
		},
		{
			MethodName: "ListForecasts",
			Handler:    _CashFlowService_ListForecasts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}

const (
	FinanceEventPublisher_PublishInvoiceCreated_FullMethodName      = "/finance.FinanceEventPublisher/PublishInvoiceCreated"
	FinanceEventPublisher_PublishPaymentReceived_FullMethodName     = "/finance.FinanceEventPublisher/PublishPaymentReceived"
	FinanceEventPublisher_PublishInventoryCostPosted_FullMethodName = "/finance.FinanceEventPublisher/PublishInventoryCostPosted"
	FinanceEventPublisher_PublishPayrollPosted_FullMethodName       = "/finance.FinanceEventPublisher/PublishPayrollPosted"
	FinanceEventPublisher_PublishVendorBillApproved_FullMethodName  = "/finance.FinanceEventPublisher/PublishVendorBillApproved"
)

// FinanceEventPublisherClient is the client API for FinanceEventPublisher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FinanceEventPublisherClient interface {
	PublishInvoiceCreated(ctx context.Context, in *FinanceInvoiceCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PublishPaymentReceived(ctx context.Context, in *FinancePaymentReceivedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PublishInventoryCostPosted(ctx context.Context, in *InventoryCostPostedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PublishPayrollPosted(ctx context.Context, in *PayrollPostedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PublishVendorBillApproved(ctx context.Context, in *VendorBillApprovedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type financeEventPublisherClient struct {
	cc grpc.ClientConnInterface
}

func NewFinanceEventPublisherClient(cc grpc.ClientConnInterface) FinanceEventPublisherClient {
	return &financeEventPublisherClient{cc}
}

func (c *financeEventPublisherClient) PublishInvoiceCreated(ctx context.Context, in *FinanceInvoiceCreatedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FinanceEventPublisher_PublishInvoiceCreated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeEventPublisherClient) PublishPaymentReceived(ctx context.Context, in *FinancePaymentReceivedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FinanceEventPublisher_PublishPaymentReceived_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeEventPublisherClient) PublishInventoryCostPosted(ctx context.Context, in *InventoryCostPostedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FinanceEventPublisher_PublishInventoryCostPosted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeEventPublisherClient) PublishPayrollPosted(ctx context.Context, in *PayrollPostedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FinanceEventPublisher_PublishPayrollPosted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *financeEventPublisherClient) PublishVendorBillApproved(ctx context.Context, in *VendorBillApprovedEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, FinanceEventPublisher_PublishVendorBillApproved_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FinanceEventPublisherServer is the server API for FinanceEventPublisher service.
// All implementations must embed UnimplementedFinanceEventPublisherServer
// for forward compatibility.
type FinanceEventPublisherServer interface {
	PublishInvoiceCreated(context.Context, *FinanceInvoiceCreatedEvent) (*emptypb.Empty, error)
	PublishPaymentReceived(context.Context, *FinancePaymentReceivedEvent) (*emptypb.Empty, error)
	PublishInventoryCostPosted(context.Context, *InventoryCostPostedEvent) (*emptypb.Empty, error)
	PublishPayrollPosted(context.Context, *PayrollPostedEvent) (*emptypb.Empty, error)
	PublishVendorBillApproved(context.Context, *VendorBillApprovedEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedFinanceEventPublisherServer()
}

// UnimplementedFinanceEventPublisherServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFinanceEventPublisherServer struct{}

func (UnimplementedFinanceEventPublisherServer) PublishInvoiceCreated(context.Context, *FinanceInvoiceCreatedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishInvoiceCreated not implemented")
}
func (UnimplementedFinanceEventPublisherServer) PublishPaymentReceived(context.Context, *FinancePaymentReceivedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishPaymentReceived not implemented")
}
func (UnimplementedFinanceEventPublisherServer) PublishInventoryCostPosted(context.Context, *InventoryCostPostedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishInventoryCostPosted not implemented")
}
func (UnimplementedFinanceEventPublisherServer) PublishPayrollPosted(context.Context, *PayrollPostedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishPayrollPosted not implemented")
}
func (UnimplementedFinanceEventPublisherServer) PublishVendorBillApproved(context.Context, *VendorBillApprovedEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishVendorBillApproved not implemented")
}
func (UnimplementedFinanceEventPublisherServer) mustEmbedUnimplementedFinanceEventPublisherServer() {}
func (UnimplementedFinanceEventPublisherServer) testEmbeddedByValue()                               {}

// UnsafeFinanceEventPublisherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FinanceEventPublisherServer will
// result in compilation errors.
type UnsafeFinanceEventPublisherServer interface {
	mustEmbedUnimplementedFinanceEventPublisherServer()
}

func RegisterFinanceEventPublisherServer(s grpc.ServiceRegistrar, srv FinanceEventPublisherServer) {
	// If the following call pancis, it indicates UnimplementedFinanceEventPublisherServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FinanceEventPublisher_ServiceDesc, srv)
}

func _FinanceEventPublisher_PublishInvoiceCreated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinanceInvoiceCreatedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceEventPublisherServer).PublishInvoiceCreated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinanceEventPublisher_PublishInvoiceCreated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceEventPublisherServer).PublishInvoiceCreated(ctx, req.(*FinanceInvoiceCreatedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceEventPublisher_PublishPaymentReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinancePaymentReceivedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceEventPublisherServer).PublishPaymentReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinanceEventPublisher_PublishPaymentReceived_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceEventPublisherServer).PublishPaymentReceived(ctx, req.(*FinancePaymentReceivedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceEventPublisher_PublishInventoryCostPosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InventoryCostPostedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceEventPublisherServer).PublishInventoryCostPosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinanceEventPublisher_PublishInventoryCostPosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceEventPublisherServer).PublishInventoryCostPosted(ctx, req.(*InventoryCostPostedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceEventPublisher_PublishPayrollPosted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PayrollPostedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceEventPublisherServer).PublishPayrollPosted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinanceEventPublisher_PublishPayrollPosted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceEventPublisherServer).PublishPayrollPosted(ctx, req.(*PayrollPostedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _FinanceEventPublisher_PublishVendorBillApproved_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VendorBillApprovedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FinanceEventPublisherServer).PublishVendorBillApproved(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FinanceEventPublisher_PublishVendorBillApproved_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FinanceEventPublisherServer).PublishVendorBillApproved(ctx, req.(*VendorBillApprovedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// FinanceEventPublisher_ServiceDesc is the grpc.ServiceDesc for FinanceEventPublisher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FinanceEventPublisher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "finance.FinanceEventPublisher",
	HandlerType: (*FinanceEventPublisherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PublishInvoiceCreated",
			Handler:    _FinanceEventPublisher_PublishInvoiceCreated_Handler,
		},
		{
			MethodName: "PublishPaymentReceived",
			Handler:    _FinanceEventPublisher_PublishPaymentReceived_Handler,
		},
		{
			MethodName: "PublishInventoryCostPosted",
			Handler:    _FinanceEventPublisher_PublishInventoryCostPosted_Handler,
		},
		{
			MethodName: "PublishPayrollPosted",
			Handler:    _FinanceEventPublisher_PublishPayrollPosted_Handler,
		},
		{
			MethodName: "PublishVendorBillApproved",
			Handler:    _FinanceEventPublisher_PublishVendorBillApproved_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "finance.proto",
}
