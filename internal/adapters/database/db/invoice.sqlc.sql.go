// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoice.sqlc.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addInvoiceDiscount = `-- name: AddInvoiceDiscount :one
INSERT INTO invoice_discounts (invoice_id, description, amount)
VALUES ($1, $2, $3) RETURNING id, invoice_id, description, amount, created_at, created_by, revision
`

type AddInvoiceDiscountParams struct {
	InvoiceID   uuid.UUID
	Description sql.NullString
	Amount      string
}

func (q *Queries) AddInvoiceDiscount(ctx context.Context, arg AddInvoiceDiscountParams) (InvoiceDiscount, error) {
	row := q.db.QueryRowContext(ctx, addInvoiceDiscount, arg.InvoiceID, arg.Description, arg.Amount)
	var i InvoiceDiscount
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Amount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Revision,
	)
	return i, err
}

const addInvoiceTax = `-- name: AddInvoiceTax :one
INSERT INTO invoice_taxes (invoice_id, name, rate, amount)
VALUES ($1, $2, $3, $4) RETURNING id, invoice_id, name, rate, amount, created_at, created_by, revision
`

type AddInvoiceTaxParams struct {
	InvoiceID uuid.UUID
	Name      string
	Rate      string
	Amount    string
}

func (q *Queries) AddInvoiceTax(ctx context.Context, arg AddInvoiceTaxParams) (InvoiceTax, error) {
	row := q.db.QueryRowContext(ctx, addInvoiceTax,
		arg.InvoiceID,
		arg.Name,
		arg.Rate,
		arg.Amount,
	)
	var i InvoiceTax
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Name,
		&i.Rate,
		&i.Amount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Revision,
	)
	return i, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
    invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date,
    lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, gst_cgst, gst_sgst, gst_igst, gst_rate, grand_total,
    created_by, updated_by, revision
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11, $12, $13, $14,
    $15, $16, $17, $18,
    $19, $20,
    $21, $22, $23, $24, $25, $26,
    $27, $28) RETURNING id, invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date, lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, grand_total, gst_rate, gst_cgst, gst_sgst, gst_igst, created_at, created_by, updated_at, updated_by, revision
`

type CreateInvoiceParams struct {
	InvoiceNumber        string
	Type                 string
	InvoiceDate          time.Time
	DueDate              sql.NullTime
	DeliveryDate         sql.NullTime
	OrganizationID       string
	PoNumber             sql.NullString
	EwayNumberLegacy     sql.NullString
	StatusNote           sql.NullString
	Status               string
	PaymentReference     sql.NullString
	ChallanNumber        sql.NullString
	ChallanDate          sql.NullTime
	LrNumber             sql.NullString
	TransporterName      sql.NullString
	TransporterID        sql.NullString
	VehicleNumber        sql.NullString
	AgainstInvoiceNumber sql.NullString
	AgainstInvoiceDate   sql.NullTime
	Subtotal             string
	GstCgst              sql.NullString
	GstSgst              sql.NullString
	GstIgst              sql.NullString
	GstRate              sql.NullString
	GrandTotal           string
	CreatedBy            sql.NullString
	UpdatedBy            sql.NullString
	Revision             sql.NullInt32
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, createInvoice,
		arg.InvoiceNumber,
		arg.Type,
		arg.InvoiceDate,
		arg.DueDate,
		arg.DeliveryDate,
		arg.OrganizationID,
		arg.PoNumber,
		arg.EwayNumberLegacy,
		arg.StatusNote,
		arg.Status,
		arg.PaymentReference,
		arg.ChallanNumber,
		arg.ChallanDate,
		arg.LrNumber,
		arg.TransporterName,
		arg.TransporterID,
		arg.VehicleNumber,
		arg.AgainstInvoiceNumber,
		arg.AgainstInvoiceDate,
		arg.Subtotal,
		arg.GstCgst,
		arg.GstSgst,
		arg.GstIgst,
		arg.GstRate,
		arg.GrandTotal,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.Revision,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Type,
		&i.InvoiceDate,
		&i.DueDate,
		&i.DeliveryDate,
		&i.OrganizationID,
		&i.PoNumber,
		&i.EwayNumberLegacy,
		&i.StatusNote,
		&i.Status,
		&i.PaymentReference,
		&i.ChallanNumber,
		&i.ChallanDate,
		&i.LrNumber,
		&i.TransporterName,
		&i.TransporterID,
		&i.VehicleNumber,
		&i.AgainstInvoiceNumber,
		&i.AgainstInvoiceDate,
		&i.Subtotal,
		&i.GrandTotal,
		&i.GstRate,
		&i.GstCgst,
		&i.GstSgst,
		&i.GstIgst,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const createInvoiceItem = `-- name: CreateInvoiceItem :one
INSERT INTO invoice_items (
    invoice_id, name, description, hsn, quantity, unit_price, line_subtotal, line_total, cost_center_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, invoice_id, name, description, hsn, quantity, unit_price, line_subtotal, line_total, cost_center_id, created_at, created_by, updated_at, updated_by, revision
`

type CreateInvoiceItemParams struct {
	InvoiceID    uuid.UUID
	Name         string
	Description  sql.NullString
	Hsn          sql.NullString
	Quantity     int32
	UnitPrice    string
	LineSubtotal string
	LineTotal    string
	CostCenterID sql.NullString
}

func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) (InvoiceItem, error) {
	row := q.db.QueryRowContext(ctx, createInvoiceItem,
		arg.InvoiceID,
		arg.Name,
		arg.Description,
		arg.Hsn,
		arg.Quantity,
		arg.UnitPrice,
		arg.LineSubtotal,
		arg.LineTotal,
		arg.CostCenterID,
	)
	var i InvoiceItem
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Name,
		&i.Description,
		&i.Hsn,
		&i.Quantity,
		&i.UnitPrice,
		&i.LineSubtotal,
		&i.LineTotal,
		&i.CostCenterID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM invoices WHERE id = $1
`

func (q *Queries) DeleteInvoice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvoice, id)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT id, invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date, lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, grand_total, gst_rate, gst_cgst, gst_sgst, gst_igst, created_at, created_by, updated_at, updated_by, revision FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoice(ctx context.Context, id uuid.UUID) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, getInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Type,
		&i.InvoiceDate,
		&i.DueDate,
		&i.DeliveryDate,
		&i.OrganizationID,
		&i.PoNumber,
		&i.EwayNumberLegacy,
		&i.StatusNote,
		&i.Status,
		&i.PaymentReference,
		&i.ChallanNumber,
		&i.ChallanDate,
		&i.LrNumber,
		&i.TransporterName,
		&i.TransporterID,
		&i.VehicleNumber,
		&i.AgainstInvoiceNumber,
		&i.AgainstInvoiceDate,
		&i.Subtotal,
		&i.GrandTotal,
		&i.GstRate,
		&i.GstCgst,
		&i.GstSgst,
		&i.GstIgst,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const listInvoiceItems = `-- name: ListInvoiceItems :many
SELECT id, invoice_id, name, description, hsn, quantity, unit_price, line_subtotal, line_total, cost_center_id, created_at, created_by, updated_at, updated_by, revision FROM invoice_items WHERE invoice_id = $1
`

func (q *Queries) ListInvoiceItems(ctx context.Context, invoiceID uuid.UUID) ([]InvoiceItem, error) {
	rows, err := q.db.QueryContext(ctx, listInvoiceItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvoiceItem
	for rows.Next() {
		var i InvoiceItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Name,
			&i.Description,
			&i.Hsn,
			&i.Quantity,
			&i.UnitPrice,
			&i.LineSubtotal,
			&i.LineTotal,
			&i.CostCenterID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoices = `-- name: ListInvoices :many
SELECT id, invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date, lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, grand_total, gst_rate, gst_cgst, gst_sgst, gst_igst, created_at, created_by, updated_at, updated_by, revision FROM invoices ORDER BY invoice_date DESC LIMIT $1 OFFSET $2
`

type ListInvoicesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListInvoices(ctx context.Context, arg ListInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.QueryContext(ctx, listInvoices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Type,
			&i.InvoiceDate,
			&i.DueDate,
			&i.DeliveryDate,
			&i.OrganizationID,
			&i.PoNumber,
			&i.EwayNumberLegacy,
			&i.StatusNote,
			&i.Status,
			&i.PaymentReference,
			&i.ChallanNumber,
			&i.ChallanDate,
			&i.LrNumber,
			&i.TransporterName,
			&i.TransporterID,
			&i.VehicleNumber,
			&i.AgainstInvoiceNumber,
			&i.AgainstInvoiceDate,
			&i.Subtotal,
			&i.GrandTotal,
			&i.GstRate,
			&i.GstCgst,
			&i.GstSgst,
			&i.GstIgst,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInvoices = `-- name: SearchInvoices :many
SELECT id, invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date, lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, grand_total, gst_rate, gst_cgst, gst_sgst, gst_igst, created_at, created_by, updated_at, updated_by, revision
FROM invoices
WHERE 
    (invoice_number ILIKE '%' || $1 || '%'
     OR po_number ILIKE '%' || $1 || '%'
     OR status_note ILIKE '%' || $1 || '%'
     OR payment_reference ILIKE '%' || $1 || '%'
     OR transporter_name ILIKE '%' || $1 || '%'
     OR transporter_id ILIKE '%' || $1 || '%'
     OR vehicle_number ILIKE '%' || $1 || '%')
ORDER BY invoice_date DESC
LIMIT $2 OFFSET $3
`

type SearchInvoicesParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchInvoices(ctx context.Context, arg SearchInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.QueryContext(ctx, searchInvoices, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invoice
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.Type,
			&i.InvoiceDate,
			&i.DueDate,
			&i.DeliveryDate,
			&i.OrganizationID,
			&i.PoNumber,
			&i.EwayNumberLegacy,
			&i.StatusNote,
			&i.Status,
			&i.PaymentReference,
			&i.ChallanNumber,
			&i.ChallanDate,
			&i.LrNumber,
			&i.TransporterName,
			&i.TransporterID,
			&i.VehicleNumber,
			&i.AgainstInvoiceNumber,
			&i.AgainstInvoiceDate,
			&i.Subtotal,
			&i.GrandTotal,
			&i.GstRate,
			&i.GstCgst,
			&i.GstSgst,
			&i.GstIgst,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE invoices
SET 
    invoice_number       = $2,
    type                 = $3,
    invoice_date         = $4,
    due_date             = $5,
    delivery_date        = $6,
    organization_id      = $7,
    po_number            = $8,
    eway_number_legacy   = $9,
    status_note          = $10,
    status               = $11,
    payment_reference    = $12,
    challan_number       = $13,
    challan_date         = $14,
    lr_number            = $15,
    transporter_name     = $16,
    transporter_id       = $17,
    vehicle_number       = $18,
    against_invoice_number = $19,
    against_invoice_date = $20,
    subtotal             = $21,
    grand_total          = $22,
    gst_rate             = $23,
    gst_cgst             = $24,
    gst_sgst             = $25,
    gst_igst             = $26,
    updated_by           = $27,
    revision             = $28,
    updated_at           = now()
WHERE id = $1
RETURNING id, invoice_number, type, invoice_date, due_date, delivery_date, organization_id, po_number, eway_number_legacy, status_note, status, payment_reference, challan_number, challan_date, lr_number, transporter_name, transporter_id, vehicle_number, against_invoice_number, against_invoice_date, subtotal, grand_total, gst_rate, gst_cgst, gst_sgst, gst_igst, created_at, created_by, updated_at, updated_by, revision
`

type UpdateInvoiceParams struct {
	ID                   uuid.UUID
	InvoiceNumber        string
	Type                 string
	InvoiceDate          time.Time
	DueDate              sql.NullTime
	DeliveryDate         sql.NullTime
	OrganizationID       string
	PoNumber             sql.NullString
	EwayNumberLegacy     sql.NullString
	StatusNote           sql.NullString
	Status               string
	PaymentReference     sql.NullString
	ChallanNumber        sql.NullString
	ChallanDate          sql.NullTime
	LrNumber             sql.NullString
	TransporterName      sql.NullString
	TransporterID        sql.NullString
	VehicleNumber        sql.NullString
	AgainstInvoiceNumber sql.NullString
	AgainstInvoiceDate   sql.NullTime
	Subtotal             string
	GrandTotal           string
	GstRate              sql.NullString
	GstCgst              sql.NullString
	GstSgst              sql.NullString
	GstIgst              sql.NullString
	UpdatedBy            sql.NullString
	Revision             sql.NullInt32
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRowContext(ctx, updateInvoice,
		arg.ID,
		arg.InvoiceNumber,
		arg.Type,
		arg.InvoiceDate,
		arg.DueDate,
		arg.DeliveryDate,
		arg.OrganizationID,
		arg.PoNumber,
		arg.EwayNumberLegacy,
		arg.StatusNote,
		arg.Status,
		arg.PaymentReference,
		arg.ChallanNumber,
		arg.ChallanDate,
		arg.LrNumber,
		arg.TransporterName,
		arg.TransporterID,
		arg.VehicleNumber,
		arg.AgainstInvoiceNumber,
		arg.AgainstInvoiceDate,
		arg.Subtotal,
		arg.GrandTotal,
		arg.GstRate,
		arg.GstCgst,
		arg.GstSgst,
		arg.GstIgst,
		arg.UpdatedBy,
		arg.Revision,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.Type,
		&i.InvoiceDate,
		&i.DueDate,
		&i.DeliveryDate,
		&i.OrganizationID,
		&i.PoNumber,
		&i.EwayNumberLegacy,
		&i.StatusNote,
		&i.Status,
		&i.PaymentReference,
		&i.ChallanNumber,
		&i.ChallanDate,
		&i.LrNumber,
		&i.TransporterName,
		&i.TransporterID,
		&i.VehicleNumber,
		&i.AgainstInvoiceNumber,
		&i.AgainstInvoiceDate,
		&i.Subtotal,
		&i.GrandTotal,
		&i.GstRate,
		&i.GstCgst,
		&i.GstSgst,
		&i.GstIgst,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}
