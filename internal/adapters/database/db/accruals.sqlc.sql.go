// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: accruals.sqlc.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addAccrualExternalRef = `-- name: AddAccrualExternalRef :one
INSERT INTO accrual_external_refs (accrual_id, system, ref_id)
VALUES ($1, $2, $3) RETURNING id, accrual_id, system, ref_id, created_at
`

type AddAccrualExternalRefParams struct {
	AccrualID uuid.UUID
	System    string
	RefID     string
}

// External refs for accrual
func (q *Queries) AddAccrualExternalRef(ctx context.Context, arg AddAccrualExternalRefParams) (AccrualExternalRef, error) {
	row := q.db.QueryRowContext(ctx, addAccrualExternalRef, arg.AccrualID, arg.System, arg.RefID)
	var i AccrualExternalRef
	err := row.Scan(
		&i.ID,
		&i.AccrualID,
		&i.System,
		&i.RefID,
		&i.CreatedAt,
	)
	return i, err
}

const createAccrual = `-- name: CreateAccrual :one

INSERT INTO accruals (
    description, amount, accrual_date, account_id,
    created_by, updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, description, amount, accrual_date, account_id, created_at, created_by, updated_at, updated_by, revision
`

type CreateAccrualParams struct {
	Description sql.NullString
	Amount      string
	AccrualDate time.Time
	AccountID   string
	CreatedBy   sql.NullString
	UpdatedBy   sql.NullString
}

// =====================================================
// Accrual Queries
// =====================================================
func (q *Queries) CreateAccrual(ctx context.Context, arg CreateAccrualParams) (Accrual, error) {
	row := q.db.QueryRowContext(ctx, createAccrual,
		arg.Description,
		arg.Amount,
		arg.AccrualDate,
		arg.AccountID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Accrual
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AccrualDate,
		&i.AccountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const createAllocationRule = `-- name: CreateAllocationRule :one

INSERT INTO allocation_rules (
    name, basis, source_account_id, target_cost_center_ids,
    formula, created_by, updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, basis, source_account_id, target_cost_center_ids, formula, created_at, created_by, updated_at, updated_by, revision
`

type CreateAllocationRuleParams struct {
	Name                string
	Basis               string
	SourceAccountID     string
	TargetCostCenterIds []string
	Formula             sql.NullString
	CreatedBy           sql.NullString
	UpdatedBy           sql.NullString
}

// =====================================================
// Allocation Rule Queries
// =====================================================
func (q *Queries) CreateAllocationRule(ctx context.Context, arg CreateAllocationRuleParams) (AllocationRule, error) {
	row := q.db.QueryRowContext(ctx, createAllocationRule,
		arg.Name,
		arg.Basis,
		arg.SourceAccountID,
		pq.Array(arg.TargetCostCenterIds),
		arg.Formula,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i AllocationRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Basis,
		&i.SourceAccountID,
		pq.Array(&i.TargetCostCenterIds),
		&i.Formula,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const deleteAccrual = `-- name: DeleteAccrual :exec
DELETE FROM accruals WHERE id = $1
`

func (q *Queries) DeleteAccrual(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAccrual, id)
	return err
}

const deleteAllocationRule = `-- name: DeleteAllocationRule :exec
DELETE FROM allocation_rules WHERE id = $1
`

func (q *Queries) DeleteAllocationRule(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAllocationRule, id)
	return err
}

const getAccrualById = `-- name: GetAccrualById :one
SELECT id, description, amount, accrual_date, account_id, created_at, created_by, updated_at, updated_by, revision FROM accruals WHERE id = $1
`

func (q *Queries) GetAccrualById(ctx context.Context, id uuid.UUID) (Accrual, error) {
	row := q.db.QueryRowContext(ctx, getAccrualById, id)
	var i Accrual
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AccrualDate,
		&i.AccountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const getAllocationRule = `-- name: GetAllocationRule :one
SELECT id, name, basis, source_account_id, target_cost_center_ids, formula, created_at, created_by, updated_at, updated_by, revision FROM allocation_rules WHERE id = $1
`

func (q *Queries) GetAllocationRule(ctx context.Context, id uuid.UUID) (AllocationRule, error) {
	row := q.db.QueryRowContext(ctx, getAllocationRule, id)
	var i AllocationRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Basis,
		&i.SourceAccountID,
		pq.Array(&i.TargetCostCenterIds),
		&i.Formula,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const listAccrualExternalRefs = `-- name: ListAccrualExternalRefs :many
SELECT id, accrual_id, system, ref_id, created_at FROM accrual_external_refs WHERE accrual_id = $1
`

func (q *Queries) ListAccrualExternalRefs(ctx context.Context, accrualID uuid.UUID) ([]AccrualExternalRef, error) {
	rows, err := q.db.QueryContext(ctx, listAccrualExternalRefs, accrualID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccrualExternalRef
	for rows.Next() {
		var i AccrualExternalRef
		if err := rows.Scan(
			&i.ID,
			&i.AccrualID,
			&i.System,
			&i.RefID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccruals = `-- name: ListAccruals :many
SELECT id, description, amount, accrual_date, account_id, created_at, created_by, updated_at, updated_by, revision FROM accruals
ORDER BY accrual_date DESC
LIMIT $1 OFFSET $2
`

type ListAccrualsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAccruals(ctx context.Context, arg ListAccrualsParams) ([]Accrual, error) {
	rows, err := q.db.QueryContext(ctx, listAccruals, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Accrual
	for rows.Next() {
		var i Accrual
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.AccrualDate,
			&i.AccountID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllocationRules = `-- name: ListAllocationRules :many
SELECT id, name, basis, source_account_id, target_cost_center_ids, formula, created_at, created_by, updated_at, updated_by, revision FROM allocation_rules
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListAllocationRulesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListAllocationRules(ctx context.Context, arg ListAllocationRulesParams) ([]AllocationRule, error) {
	rows, err := q.db.QueryContext(ctx, listAllocationRules, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllocationRule
	for rows.Next() {
		var i AllocationRule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Basis,
			&i.SourceAccountID,
			pq.Array(&i.TargetCostCenterIds),
			&i.Formula,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccrual = `-- name: UpdateAccrual :one
UPDATE accruals
SET description = $2,
    amount = $3,
    accrual_date = $4,
    account_id = $5,
    updated_by = $6,
    revision = revision + 1,
    updated_at = now()
WHERE id = $1
RETURNING id, description, amount, accrual_date, account_id, created_at, created_by, updated_at, updated_by, revision
`

type UpdateAccrualParams struct {
	ID          uuid.UUID
	Description sql.NullString
	Amount      string
	AccrualDate time.Time
	AccountID   string
	UpdatedBy   sql.NullString
}

func (q *Queries) UpdateAccrual(ctx context.Context, arg UpdateAccrualParams) (Accrual, error) {
	row := q.db.QueryRowContext(ctx, updateAccrual,
		arg.ID,
		arg.Description,
		arg.Amount,
		arg.AccrualDate,
		arg.AccountID,
		arg.UpdatedBy,
	)
	var i Accrual
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AccrualDate,
		&i.AccountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const updateAllocationRule = `-- name: UpdateAllocationRule :one
UPDATE allocation_rules
SET name = $2,
    basis = $3,
    source_account_id = $4,
    target_cost_center_ids = $5,
    formula = $6,
    updated_by = $7,
    revision = revision + 1,
    updated_at = now()
WHERE id = $1
RETURNING id, name, basis, source_account_id, target_cost_center_ids, formula, created_at, created_by, updated_at, updated_by, revision
`

type UpdateAllocationRuleParams struct {
	ID                  uuid.UUID
	Name                string
	Basis               string
	SourceAccountID     string
	TargetCostCenterIds []string
	Formula             sql.NullString
	UpdatedBy           sql.NullString
}

func (q *Queries) UpdateAllocationRule(ctx context.Context, arg UpdateAllocationRuleParams) (AllocationRule, error) {
	row := q.db.QueryRowContext(ctx, updateAllocationRule,
		arg.ID,
		arg.Name,
		arg.Basis,
		arg.SourceAccountID,
		pq.Array(arg.TargetCostCenterIds),
		arg.Formula,
		arg.UpdatedBy,
	)
	var i AllocationRule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Basis,
		&i.SourceAccountID,
		pq.Array(&i.TargetCostCenterIds),
		&i.Formula,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}
