// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: budgets.sqlc.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const allocateBudget = `-- name: AllocateBudget :one

INSERT INTO budget_allocations (budget_id, department_id, allocated_amount, spent_amount, created_by, updated_by)
VALUES ($1, $2, $3, COALESCE($4, 0), $5, $6)
RETURNING id, budget_id, department_id, allocated_amount, spent_amount, remaining_amount, created_at, created_by, updated_at, updated_by, revision
`

type AllocateBudgetParams struct {
	BudgetID        uuid.UUID
	DepartmentID    string
	AllocatedAmount string
	Column4         interface{}
	CreatedBy       sql.NullString
	UpdatedBy       sql.NullString
}

// =====================================================
// Budget Allocations
// =====================================================
func (q *Queries) AllocateBudget(ctx context.Context, arg AllocateBudgetParams) (BudgetAllocation, error) {
	row := q.db.QueryRowContext(ctx, allocateBudget,
		arg.BudgetID,
		arg.DepartmentID,
		arg.AllocatedAmount,
		arg.Column4,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.DepartmentID,
		&i.AllocatedAmount,
		&i.SpentAmount,
		&i.RemainingAmount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const createBudget = `-- name: CreateBudget :one

INSERT INTO budgets (name, total_amount, status, created_by, updated_by)
VALUES ($1, $2, COALESCE($3, 'DRAFT'), $4, $5)
RETURNING id, name, total_amount, status, created_at, created_by, updated_at, updated_by, revision
`

type CreateBudgetParams struct {
	Name        string
	TotalAmount string
	Column3     interface{}
	CreatedBy   sql.NullString
	UpdatedBy   sql.NullString
}

// =====================================================
// Budgets
// =====================================================
func (q *Queries) CreateBudget(ctx context.Context, arg CreateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, createBudget,
		arg.Name,
		arg.TotalAmount,
		arg.Column3,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const deleteBudget = `-- name: DeleteBudget :exec
DELETE FROM budgets WHERE id = $1
`

func (q *Queries) DeleteBudget(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBudget, id)
	return err
}

const deleteBudgetAllocation = `-- name: DeleteBudgetAllocation :exec
DELETE FROM budget_allocations WHERE id = $1
`

func (q *Queries) DeleteBudgetAllocation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBudgetAllocation, id)
	return err
}

const getBudget = `-- name: GetBudget :one
SELECT id, name, total_amount, status, created_at, created_by, updated_at, updated_by, revision FROM budgets WHERE id = $1
`

func (q *Queries) GetBudget(ctx context.Context, id uuid.UUID) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudget, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const getBudgetAllocation = `-- name: GetBudgetAllocation :one
SELECT id, budget_id, department_id, allocated_amount, spent_amount, remaining_amount, created_at, created_by, updated_at, updated_by, revision FROM budget_allocations WHERE id = $1
`

func (q *Queries) GetBudgetAllocation(ctx context.Context, id uuid.UUID) (BudgetAllocation, error) {
	row := q.db.QueryRowContext(ctx, getBudgetAllocation, id)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.DepartmentID,
		&i.AllocatedAmount,
		&i.SpentAmount,
		&i.RemainingAmount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const getBudgetComparisonReport = `-- name: GetBudgetComparisonReport :one

SELECT 
    b.id as budget_id,
    b.total_amount as total_budget,
    COALESCE(SUM(a.allocated_amount), 0) as total_allocated,
    COALESCE(SUM(a.spent_amount), 0) as total_spent,
    (b.total_amount - COALESCE(SUM(a.spent_amount), 0)) as remaining_budget
FROM budgets b
LEFT JOIN budget_allocations a ON b.id = a.budget_id
WHERE b.id = $1
GROUP BY b.id, b.total_amount
`

type GetBudgetComparisonReportRow struct {
	BudgetID        uuid.UUID
	TotalBudget     string
	TotalAllocated  interface{}
	TotalSpent      interface{}
	RemainingBudget int32
}

// =====================================================
// Budget Comparison (Report)
// =====================================================
func (q *Queries) GetBudgetComparisonReport(ctx context.Context, id uuid.UUID) (GetBudgetComparisonReportRow, error) {
	row := q.db.QueryRowContext(ctx, getBudgetComparisonReport, id)
	var i GetBudgetComparisonReportRow
	err := row.Scan(
		&i.BudgetID,
		&i.TotalBudget,
		&i.TotalAllocated,
		&i.TotalSpent,
		&i.RemainingBudget,
	)
	return i, err
}

const listBudgetAllocations = `-- name: ListBudgetAllocations :many
SELECT id, budget_id, department_id, allocated_amount, spent_amount, remaining_amount, created_at, created_by, updated_at, updated_by, revision FROM budget_allocations
WHERE budget_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListBudgetAllocationsParams struct {
	BudgetID uuid.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) ListBudgetAllocations(ctx context.Context, arg ListBudgetAllocationsParams) ([]BudgetAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listBudgetAllocations, arg.BudgetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BudgetAllocation
	for rows.Next() {
		var i BudgetAllocation
		if err := rows.Scan(
			&i.ID,
			&i.BudgetID,
			&i.DepartmentID,
			&i.AllocatedAmount,
			&i.SpentAmount,
			&i.RemainingAmount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBudgets = `-- name: ListBudgets :many
SELECT id, name, total_amount, status, created_at, created_by, updated_at, updated_by, revision FROM budgets
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListBudgetsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListBudgets(ctx context.Context, arg ListBudgetsParams) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, listBudgets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Budget
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBudget = `-- name: UpdateBudget :one
UPDATE budgets
SET 
    name = $2,
    total_amount = $3,
    status = $4,
    updated_by = $5,
    updated_at = now(),
    revision = revision + 1
WHERE id = $1
RETURNING id, name, total_amount, status, created_at, created_by, updated_at, updated_by, revision
`

type UpdateBudgetParams struct {
	ID          uuid.UUID
	Name        string
	TotalAmount string
	Status      string
	UpdatedBy   sql.NullString
}

func (q *Queries) UpdateBudget(ctx context.Context, arg UpdateBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, updateBudget,
		arg.ID,
		arg.Name,
		arg.TotalAmount,
		arg.Status,
		arg.UpdatedBy,
	)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const updateBudgetAllocation = `-- name: UpdateBudgetAllocation :one
UPDATE budget_allocations
SET 
    department_id = $2,
    allocated_amount = $3,
    spent_amount = $4,
    updated_by = $5,
    updated_at = now(),
    revision = revision + 1
WHERE id = $1
RETURNING id, budget_id, department_id, allocated_amount, spent_amount, remaining_amount, created_at, created_by, updated_at, updated_by, revision
`

type UpdateBudgetAllocationParams struct {
	ID              uuid.UUID
	DepartmentID    string
	AllocatedAmount string
	SpentAmount     sql.NullString
	UpdatedBy       sql.NullString
}

func (q *Queries) UpdateBudgetAllocation(ctx context.Context, arg UpdateBudgetAllocationParams) (BudgetAllocation, error) {
	row := q.db.QueryRowContext(ctx, updateBudgetAllocation,
		arg.ID,
		arg.DepartmentID,
		arg.AllocatedAmount,
		arg.SpentAmount,
		arg.UpdatedBy,
	)
	var i BudgetAllocation
	err := row.Scan(
		&i.ID,
		&i.BudgetID,
		&i.DepartmentID,
		&i.AllocatedAmount,
		&i.SpentAmount,
		&i.RemainingAmount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}
