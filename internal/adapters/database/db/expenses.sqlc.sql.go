// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: expenses.sqlc.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const allocateCost = `-- name: AllocateCost :one

INSERT INTO cost_allocations (cost_center_id, amount, reference_type, reference_id, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, cost_center_id, amount, reference_type, reference_id, created_at, created_by, updated_at, updated_by, revision
`

type AllocateCostParams struct {
	CostCenterID  uuid.UUID
	Amount        string
	ReferenceType string
	ReferenceID   string
	CreatedBy     sql.NullString
	UpdatedBy     sql.NullString
}

// =====================================================
// Cost Allocation Queries
// =====================================================
func (q *Queries) AllocateCost(ctx context.Context, arg AllocateCostParams) (CostAllocation, error) {
	row := q.db.QueryRowContext(ctx, allocateCost,
		arg.CostCenterID,
		arg.Amount,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CostAllocation
	err := row.Scan(
		&i.ID,
		&i.CostCenterID,
		&i.Amount,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const createCostCenter = `-- name: CreateCostCenter :one

INSERT INTO cost_centers (name, description, created_by, updated_by)
VALUES ($1, $2, $3, $4)
RETURNING id, name, description, created_at, created_by, updated_at, updated_by, revision
`

type CreateCostCenterParams struct {
	Name        string
	Description sql.NullString
	CreatedBy   sql.NullString
	UpdatedBy   sql.NullString
}

// =====================================================
// Cost Center Queries
// =====================================================
func (q *Queries) CreateCostCenter(ctx context.Context, arg CreateCostCenterParams) (CostCenter, error) {
	row := q.db.QueryRowContext(ctx, createCostCenter,
		arg.Name,
		arg.Description,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CostCenter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const createExpense = `-- name: CreateExpense :one

INSERT INTO expenses (category, amount, expense_date, cost_center_id, created_by, updated_by)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, category, amount, expense_date, cost_center_id, created_at, created_by, updated_at, updated_by, revision
`

type CreateExpenseParams struct {
	Category     string
	Amount       string
	ExpenseDate  time.Time
	CostCenterID uuid.NullUUID
	CreatedBy    sql.NullString
	UpdatedBy    sql.NullString
}

// =====================================================
// Expense Queries
// =====================================================
func (q *Queries) CreateExpense(ctx context.Context, arg CreateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, createExpense,
		arg.Category,
		arg.Amount,
		arg.ExpenseDate,
		arg.CostCenterID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Amount,
		&i.ExpenseDate,
		&i.CostCenterID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const deleteCostCenter = `-- name: DeleteCostCenter :exec
DELETE FROM cost_centers WHERE id = $1
`

func (q *Queries) DeleteCostCenter(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCostCenter, id)
	return err
}

const deleteExpense = `-- name: DeleteExpense :exec
DELETE FROM expenses WHERE id = $1
`

func (q *Queries) DeleteExpense(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteExpense, id)
	return err
}

const getCostCenter = `-- name: GetCostCenter :one
SELECT id, name, description, created_at, created_by, updated_at, updated_by, revision FROM cost_centers WHERE id = $1
`

func (q *Queries) GetCostCenter(ctx context.Context, id uuid.UUID) (CostCenter, error) {
	row := q.db.QueryRowContext(ctx, getCostCenter, id)
	var i CostCenter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const getExpense = `-- name: GetExpense :one
SELECT id, category, amount, expense_date, cost_center_id, created_at, created_by, updated_at, updated_by, revision FROM expenses WHERE id = $1
`

func (q *Queries) GetExpense(ctx context.Context, id uuid.UUID) (Expense, error) {
	row := q.db.QueryRowContext(ctx, getExpense, id)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Amount,
		&i.ExpenseDate,
		&i.CostCenterID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const listCostAllocations = `-- name: ListCostAllocations :many
SELECT id, cost_center_id, amount, reference_type, reference_id, created_at, created_by, updated_at, updated_by, revision FROM cost_allocations
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCostAllocationsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListCostAllocations(ctx context.Context, arg ListCostAllocationsParams) ([]CostAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listCostAllocations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CostAllocation
	for rows.Next() {
		var i CostAllocation
		if err := rows.Scan(
			&i.ID,
			&i.CostCenterID,
			&i.Amount,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCostCenters = `-- name: ListCostCenters :many
SELECT id, name, description, created_at, created_by, updated_at, updated_by, revision FROM cost_centers
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type ListCostCentersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListCostCenters(ctx context.Context, arg ListCostCentersParams) ([]CostCenter, error) {
	rows, err := q.db.QueryContext(ctx, listCostCenters, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CostCenter
	for rows.Next() {
		var i CostCenter
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpenses = `-- name: ListExpenses :many
SELECT id, category, amount, expense_date, cost_center_id, created_at, created_by, updated_at, updated_by, revision FROM expenses
ORDER BY expense_date DESC
LIMIT $1 OFFSET $2
`

type ListExpensesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListExpenses(ctx context.Context, arg ListExpensesParams) ([]Expense, error) {
	rows, err := q.db.QueryContext(ctx, listExpenses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expense
	for rows.Next() {
		var i Expense
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Amount,
			&i.ExpenseDate,
			&i.CostCenterID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCostCenter = `-- name: UpdateCostCenter :one
UPDATE cost_centers
SET name = $2,
    description = $3,
    updated_by = $4,
    revision = revision + 1,
    updated_at = now()
WHERE id = $1
RETURNING id, name, description, created_at, created_by, updated_at, updated_by, revision
`

type UpdateCostCenterParams struct {
	ID          uuid.UUID
	Name        string
	Description sql.NullString
	UpdatedBy   sql.NullString
}

func (q *Queries) UpdateCostCenter(ctx context.Context, arg UpdateCostCenterParams) (CostCenter, error) {
	row := q.db.QueryRowContext(ctx, updateCostCenter,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedBy,
	)
	var i CostCenter
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}

const updateExpense = `-- name: UpdateExpense :one
UPDATE expenses
SET category = $2,
    amount = $3,
    expense_date = $4,
    cost_center_id = $5,
    updated_by = $6,
    revision = revision + 1,
    updated_at = now()
WHERE id = $1
RETURNING id, category, amount, expense_date, cost_center_id, created_at, created_by, updated_at, updated_by, revision
`

type UpdateExpenseParams struct {
	ID           uuid.UUID
	Category     string
	Amount       string
	ExpenseDate  time.Time
	CostCenterID uuid.NullUUID
	UpdatedBy    sql.NullString
}

func (q *Queries) UpdateExpense(ctx context.Context, arg UpdateExpenseParams) (Expense, error) {
	row := q.db.QueryRowContext(ctx, updateExpense,
		arg.ID,
		arg.Category,
		arg.Amount,
		arg.ExpenseDate,
		arg.CostCenterID,
		arg.UpdatedBy,
	)
	var i Expense
	err := row.Scan(
		&i.ID,
		&i.Category,
		&i.Amount,
		&i.ExpenseDate,
		&i.CostCenterID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Revision,
	)
	return i, err
}
